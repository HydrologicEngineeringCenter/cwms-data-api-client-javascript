/* tslint:disable */
/* eslint-disable */
/**
 * CWMSJS
 * CWMS REST API for Data Retrieval
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * @type AbstractRatingMetadata
 * Rating Metadata
 * @export
 */
export type AbstractRatingMetadata = { rating_type: 'expression-rating' } & ExpressionRating | { rating_type: 'table' } & TableRating | { rating_type: 'transitional' } & TransitionalRating | { rating_type: 'usgs' } & UsgsStreamRating | { rating_type: 'virtual' } & VirtualRating;

/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'user-id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'key-name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'api-key'?: string;
    /**
     * The instant this Key was created, in ISO-8601 format with offset and timezone (\'yyyy-MM-dd\'T\'HH:mm:ssZ\'[\'VV\']\'\')
     * @type {string}
     * @memberof ApiKey
     */
    'created'?: string;
    /**
     * When this key expires, in ISO-8601 format with offset and timezone (\'yyyy-MM-dd\'T\'HH:mm:ssZ\'[\'VV\']\'\')
     * @type {string}
     * @memberof ApiKey
     */
    'expires'?: string;
}
/**
 * 
 * @export
 * @interface AssignedLocation
 */
export interface AssignedLocation {
    /**
     * 
     * @type {string}
     * @memberof AssignedLocation
     */
    'locationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssignedLocation
     */
    'officeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssignedLocation
     */
    'aliasId'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssignedLocation
     */
    'attribute'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssignedLocation
     */
    'refLocationId'?: string;
}
/**
 * 
 * @export
 * @interface AssignedTimeSeries
 */
export interface AssignedTimeSeries {
    /**
     * 
     * @type {string}
     * @memberof AssignedTimeSeries
     */
    'officeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssignedTimeSeries
     */
    'timeseriesId'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssignedTimeSeries
     */
    'tsCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssignedTimeSeries
     */
    'aliasId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssignedTimeSeries
     */
    'refTsId'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssignedTimeSeries
     */
    'attribute'?: number;
}
/**
 * 
 * @export
 * @interface Basin
 */
export interface Basin {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof Basin
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof Basin
     */
    'basin-name'?: string;
    /**
     * 
     * @type {Stream}
     * @memberof Basin
     */
    'primary-stream'?: Stream;
    /**
     * 
     * @type {number}
     * @memberof Basin
     */
    'sort-order'?: number;
    /**
     * 
     * @type {number}
     * @memberof Basin
     */
    'basin-area'?: number;
    /**
     * 
     * @type {number}
     * @memberof Basin
     */
    'contributing-area'?: number;
    /**
     * 
     * @type {string}
     * @memberof Basin
     */
    'parent-basin-id'?: string;
}
/**
 * List of retrieved blobs
 * @export
 * @interface Blob
 */
export interface Blob {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof Blob
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof Blob
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Blob
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Blob
     */
    'media-type-id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Blob
     */
    'value'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Blobs
 */
export interface Blobs {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof Blobs
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof Blobs
     */
    'total'?: number;
    /**
     * List of retrieved blobs
     * @type {Array<Blob>}
     * @memberof Blobs
     */
    'blobs'?: Array<Blob>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof Blobs
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof Blobs
     */
    'page-size'?: number;
}
/**
 * 
 * @export
 * @interface Catalog
 */
export interface Catalog {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof Catalog
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof Catalog
     */
    'total'?: number;
    /**
     * 
     * @type {Array<CatalogEntry>}
     * @memberof Catalog
     */
    'entries'?: Array<CatalogEntry>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof Catalog
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof Catalog
     */
    'page-size'?: number;
}
/**
 * @type CatalogEntry
 * @export
 */
export type CatalogEntry = LocationCatalogEntry | TimeseriesCatalogEntry;

/**
 * Set of data for which a larger catalog can be built.
 * @export
 * @enum {string}
 */

export const CatalogableEndpoint = {
    Timeseries: 'TIMESERIES',
    Locations: 'LOCATIONS'
} as const;

export type CatalogableEndpoint = typeof CatalogableEndpoint[keyof typeof CatalogableEndpoint];


/**
 * 
 * @export
 * @interface CdaError
 */
export interface CdaError {
    /**
     * 
     * @type {string}
     * @memberof CdaError
     */
    'message'?: string;
    /**
     * A randomly generated number to help identify your request in the logs for analysis..
     * @type {string}
     * @memberof CdaError
     */
    'incidentIdentifier'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CdaError
     */
    'details'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface Clob
 */
export interface Clob {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof Clob
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof Clob
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Clob
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Clob
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Clobs
 */
export interface Clobs {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof Clobs
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof Clobs
     */
    'total'?: number;
    /**
     * List of retrieved clobs
     * @type {Array<Clob>}
     * @memberof Clobs
     */
    'clobs'?: Array<Clob>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof Clobs
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof Clobs
     */
    'page-size'?: number;
}
/**
 * A representation of a county
 * @export
 * @interface County
 */
export interface County {
    /**
     * 
     * @type {string}
     * @memberof County
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof County
     */
    'countyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof County
     */
    'stateInitial'?: string;
}
/**
 * Single Office or List of Offices in comma separated format
 * @export
 * @interface CsvV1Office
 */
export interface CsvV1Office {
    /**
     * 
     * @type {string}
     * @memberof CsvV1Office
     */
    'Office'?: string;
    /**
     * 
     * @type {string}
     * @memberof CsvV1Office
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CsvV1Office
     */
    'officeType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CsvV1Office
     */
    'reportsToOffice'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseLoadMethod = {
    Eager: 'EAGER',
    Lazy: 'LAZY',
    Reference: 'REFERENCE'
} as const;

export type DatabaseLoadMethod = typeof DatabaseLoadMethod[keyof typeof DatabaseLoadMethod];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeleteMethod = {
    All: 'DELETE_ALL',
    Key: 'DELETE_KEY',
    Data: 'DELETE_DATA'
} as const;

export type DeleteMethod = typeof DeleteMethod[keyof typeof DeleteMethod];


/**
 * 
 * @export
 * @interface ExpressionRating
 */
export interface ExpressionRating extends AbstractRatingMetadata {
    /**
     * 
     * @type {string}
     * @memberof ExpressionRating
     */
    'expression'?: string;
}
/**
 * 
 * @export
 * @interface IndependentRoundingSpec
 */
export interface IndependentRoundingSpec {
    /**
     * 
     * @type {number}
     * @memberof IndependentRoundingSpec
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof IndependentRoundingSpec
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof Location
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'longitude'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'public-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'long-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'timezone-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'location-type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'location-kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'nation'?: LocationNationEnum;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'state-initial'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'county-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'nearest-city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'horizontal-datum'?: string;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'published-longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'published-latitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'vertical-datum'?: string;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'elevation'?: number;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'map-label'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'bounding-office-id'?: string;
}

export const LocationNationEnum = {
    Us: 'US',
    Canada: 'CANADA',
    Mexico: 'MEXICO'
} as const;

export type LocationNationEnum = typeof LocationNationEnum[keyof typeof LocationNationEnum];

/**
 * 
 * @export
 * @interface LocationAlias
 */
export interface LocationAlias {
    /**
     * 
     * @type {string}
     * @memberof LocationAlias
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationAlias
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface LocationCatalogEntry
 */
export interface LocationCatalogEntry {
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'office'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'nearestCity'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'publicName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'timeZone'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationCatalogEntry
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationCatalogEntry
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationCatalogEntry
     */
    'publishedLatitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationCatalogEntry
     */
    'publishedLongitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'horizontalDatum'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationCatalogEntry
     */
    'elevation'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'verticalDatum'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'nation'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'county'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'boundingOffice'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCatalogEntry
     */
    'mapLabel'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LocationCatalogEntry
     */
    'active'?: boolean;
    /**
     * 
     * @type {Array<LocationAlias>}
     * @memberof LocationCatalogEntry
     */
    'aliases'?: Array<LocationAlias>;
}
/**
 * A representation of a location category
 * @export
 * @interface LocationCategory
 */
export interface LocationCategory {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof LocationCategory
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationCategory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationCategory
     */
    'description'?: string;
}
/**
 * A representation of a location group
 * @export
 * @interface LocationGroup
 */
export interface LocationGroup {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof LocationGroup
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof LocationGroup
     */
    'id'?: string;
    /**
     * 
     * @type {LocationCategory}
     * @memberof LocationGroup
     */
    'location-category'?: LocationCategory;
    /**
     * 
     * @type {string}
     * @memberof LocationGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationGroup
     */
    'shared-loc-alias-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationGroup
     */
    'shared-ref-location-id'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationGroup
     */
    'loc-group-attribute'?: number;
    /**
     * 
     * @type {Array<AssignedLocation>}
     * @memberof LocationGroup
     */
    'assigned-locations'?: Array<AssignedLocation>;
}
/**
 * 
 * @export
 * @interface LocationLevel
 */
export interface LocationLevel {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof LocationLevel
     */
    'office-id': string;
    /**
     * Name of the location level
     * @type {string}
     * @memberof LocationLevel
     */
    'location-level-id': string;
    /**
     * Timeseries ID (e.g. from the times series catalog) to use as the location level. Mutually exclusive with seasonalValues and siParameterUnitsConstantValue
     * @type {string}
     * @memberof LocationLevel
     */
    'seasonal-time-series-id'?: string;
    /**
     * List of Repeating seasonal values. The values repeater after the specified interval. A yearly interval seasonable could have 12 different values, one for each month for example. Mutually exclusive with seasonalTimeSeriesId and siParameterUnitsConstantValue
     * @type {Array<SeasonalValueBean>}
     * @memberof LocationLevel
     */
    'seasonal-values'?: Array<SeasonalValueBean>;
    /**
     * Generic name of this location level. Common names are \'Top of Dam\', \'Streambed\', \'Bottom of Dam\'.
     * @type {string}
     * @memberof LocationLevel
     */
    'specified-level-id'?: string;
    /**
     * To indicate if single or aggregate value
     * @type {string}
     * @memberof LocationLevel
     */
    'parameter-type-id'?: LocationLevelParameterTypeIdEnum;
    /**
     * Data Type such as Stage, Elevation, or others.
     * @type {string}
     * @memberof LocationLevel
     */
    'parameter-id'?: string;
    /**
     * Single value for this location level. Mutually exclusive with seasonableTimeSeriesId and seasonValues.
     * @type {number}
     * @memberof LocationLevel
     */
    'constant-value'?: number;
    /**
     * Units the provided levels are in
     * @type {string}
     * @memberof LocationLevel
     */
    'level-units-id'?: string;
    /**
     * The date/time at which this location level configuration takes effect.
     * @type {string}
     * @memberof LocationLevel
     */
    'level-date'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationLevel
     */
    'level-comment'?: string;
    /**
     * The start point of provided seasonal values
     * @type {string}
     * @memberof LocationLevel
     */
    'interval-origin'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationLevel
     */
    'interval-months'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocationLevel
     */
    'interval-minutes'?: number;
    /**
     * Indicating whether or not to interpolate between seasonal values.
     * @type {string}
     * @memberof LocationLevel
     */
    'interpolate-string'?: LocationLevelInterpolateStringEnum;
    /**
     * 0 if parameterTypeId is Inst. Otherwise duration indicating the time window of the aggregate value.
     * @type {string}
     * @memberof LocationLevel
     */
    'duration-id'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocationLevel
     */
    'attribute-value'?: number;
    /**
     * 
     * @type {string}
     * @memberof LocationLevel
     */
    'attribute-units-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationLevel
     */
    'attribute-parameter-type-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationLevel
     */
    'attribute-parameter-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationLevel
     */
    'attribute-duration-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationLevel
     */
    'attribute-comment'?: string;
}

export const LocationLevelParameterTypeIdEnum = {
    Inst: 'Inst',
    Ave: 'Ave',
    Min: 'Min',
    Max: 'Max',
    Total: 'Total'
} as const;

export type LocationLevelParameterTypeIdEnum = typeof LocationLevelParameterTypeIdEnum[keyof typeof LocationLevelParameterTypeIdEnum];
export const LocationLevelInterpolateStringEnum = {
    T: 'T',
    F: 'F'
} as const;

export type LocationLevelInterpolateStringEnum = typeof LocationLevelInterpolateStringEnum[keyof typeof LocationLevelInterpolateStringEnum];

/**
 * 
 * @export
 * @interface LocationLevels
 */
export interface LocationLevels {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof LocationLevels
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof LocationLevels
     */
    'total'?: number;
    /**
     * List of retrieved location levels
     * @type {Array<LocationLevel>}
     * @memberof LocationLevels
     */
    'levels'?: Array<LocationLevel>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof LocationLevels
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof LocationLevels
     */
    'page-size'?: number;
}
/**
 * A representation of a CWMS office
 * @export
 * @interface Office
 */
export interface Office {
    /**
     * 
     * @type {string}
     * @memberof Office
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Office
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Office
     */
    'type'?: OfficeTypeEnum;
    /**
     * Reference to another office, like a division, that this office reports to.
     * @type {string}
     * @memberof Office
     */
    'reportsTo'?: string;
}

export const OfficeTypeEnum = {
    Unknown: 'unknown',
    CorpsHeadquarters: 'corps headquarters',
    DivisionHeadquarters: 'division headquarters',
    DivisionRegional: 'division regional',
    District: 'district',
    FiledOperatingActivity: 'filed operating activity'
} as const;

export type OfficeTypeEnum = typeof OfficeTypeEnum[keyof typeof OfficeTypeEnum];

/**
 * Single Office or List of Offices in comma separated format
 * @export
 * @interface OfficeCSV
 */
export interface OfficeCSV {
    /**
     * 
     * @type {string}
     * @memberof OfficeCSV
     */
    'Office'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfficeCSV
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfficeCSV
     */
    'officeType'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfficeCSV
     */
    'reportsToOffice'?: string;
}
/**
 * 
 * @export
 * @interface OfficeFormatV1
 */
export interface OfficeFormatV1 {
    /**
     * 
     * @type {OfficesFMT}
     * @memberof OfficeFormatV1
     */
    'offices'?: OfficesFMT;
}
/**
 * Single Office or List of Offices in tab separated format
 * @export
 * @interface OfficeTabulation
 */
export interface OfficeTabulation {
    /**
     * 
     * @type {string}
     * @memberof OfficeTabulation
     */
    'Office'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfficeTabulation
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfficeTabulation
     */
    'officeType'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfficeTabulation
     */
    'reportsToOffice'?: string;
}
/**
 * 
 * @export
 * @interface OfficesFMT
 */
export interface OfficesFMT {
    /**
     * 
     * @type {Array<Office>}
     * @memberof OfficesFMT
     */
    'offices'?: Array<Office>;
}
/**
 * 
 * @export
 * @interface Offset
 */
export interface Offset {
    /**
     * 
     * @type {boolean}
     * @memberof Offset
     */
    'estimate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Offset
     */
    'toDatum'?: string;
    /**
     * 
     * @type {number}
     * @memberof Offset
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface ParameterSpec
 */
export interface ParameterSpec {
    /**
     * 
     * @type {string}
     * @memberof ParameterSpec
     */
    'parameter'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSpec
     */
    'in-range-method'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSpec
     */
    'out-range-low-method'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterSpec
     */
    'out-range-high-method'?: string;
}
/**
 * List of retrieved pools
 * @export
 * @interface Pool
 */
export interface Pool {
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'attribute'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'clobText'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'projectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'topLevelId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'bottomLevelId'?: string;
    /**
     * 
     * @type {PoolNameType}
     * @memberof Pool
     */
    'poolName'?: PoolNameType;
    /**
     * 
     * @type {boolean}
     * @memberof Pool
     */
    'implicit'?: boolean;
}
/**
 * 
 * @export
 * @interface PoolNameType
 */
export interface PoolNameType {
    /**
     * 
     * @type {string}
     * @memberof PoolNameType
     */
    'officeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PoolNameType
     */
    'poolName'?: string;
}
/**
 * 
 * @export
 * @interface Pools
 */
export interface Pools {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof Pools
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof Pools
     */
    'total'?: number;
    /**
     * List of retrieved pools
     * @type {Array<Pool>}
     * @memberof Pools
     */
    'pools'?: Array<Pool>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof Pools
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof Pools
     */
    'page-size'?: number;
}
/**
 * 
 * @export
 * @interface RatingMetadata
 */
export interface RatingMetadata {
    /**
     * 
     * @type {RatingSpec}
     * @memberof RatingMetadata
     */
    'rating-spec'?: RatingSpec;
    /**
     * 
     * @type {Array<AbstractRatingMetadata>}
     * @memberof RatingMetadata
     */
    'ratings'?: Array<AbstractRatingMetadata>;
}
/**
 * 
 * @export
 * @interface RatingMetadataList
 */
export interface RatingMetadataList {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof RatingMetadataList
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof RatingMetadataList
     */
    'total'?: number;
    /**
     * 
     * @type {Array<RatingMetadata>}
     * @memberof RatingMetadataList
     */
    'rating-metadata'?: Array<RatingMetadata>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof RatingMetadataList
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof RatingMetadataList
     */
    'page-size'?: number;
}
/**
 * 
 * @export
 * @interface RatingSpec
 */
export interface RatingSpec {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof RatingSpec
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'rating-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'template-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'location-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'source-agency'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'in-range-method'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'out-range-low-method'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'out-range-high-method'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RatingSpec
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RatingSpec
     */
    'auto-update'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RatingSpec
     */
    'auto-activate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RatingSpec
     */
    'auto-migrate-extension'?: boolean;
    /**
     * 
     * @type {Array<IndependentRoundingSpec>}
     * @memberof RatingSpec
     */
    'independent-rounding-specs'?: Array<IndependentRoundingSpec>;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'dependent-rounding-spec'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingSpec
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RatingSpec
     */
    'effective-dates'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RatingSpecs
 */
export interface RatingSpecs {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof RatingSpecs
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof RatingSpecs
     */
    'total'?: number;
    /**
     * 
     * @type {Array<RatingSpec>}
     * @memberof RatingSpecs
     */
    'specs'?: Array<RatingSpec>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof RatingSpecs
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof RatingSpecs
     */
    'page-size'?: number;
}
/**
 * 
 * @export
 * @interface RatingTemplate
 */
export interface RatingTemplate {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof RatingTemplate
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof RatingTemplate
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingTemplate
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingTemplate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RatingTemplate
     */
    'dependent-parameter'?: string;
    /**
     * 
     * @type {Array<ParameterSpec>}
     * @memberof RatingTemplate
     */
    'independent-parameter-specs'?: Array<ParameterSpec>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RatingTemplate
     */
    'rating-ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RatingTemplates
 */
export interface RatingTemplates {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof RatingTemplates
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof RatingTemplates
     */
    'total'?: number;
    /**
     * 
     * @type {Array<RatingTemplate>}
     * @memberof RatingTemplates
     */
    'templates'?: Array<RatingTemplate>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof RatingTemplates
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof RatingTemplates
     */
    'page-size'?: number;
}
/**
 * List of Repeating seasonal values. The values repeater after the specified interval. A yearly interval seasonable could have 12 different values, one for each month for example. Mutually exclusive with seasonalTimeSeriesId and siParameterUnitsConstantValue
 * @export
 * @interface SeasonalValueBean
 */
export interface SeasonalValueBean {
    /**
     * 
     * @type {number}
     * @memberof SeasonalValueBean
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof SeasonalValueBean
     */
    'offset-months'?: number;
    /**
     * 
     * @type {number}
     * @memberof SeasonalValueBean
     */
    'offset-minutes'?: number;
}
/**
 * 
 * @export
 * @interface SpecifiedLevel
 */
export interface SpecifiedLevel {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof SpecifiedLevel
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof SpecifiedLevel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecifiedLevel
     */
    'description'?: string;
}
/**
 * A representation of a state
 * @export
 * @interface State
 */
export interface State {
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'stateInitial'?: string;
    /**
     * 
     * @type {string}
     * @memberof State
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StoreRule = {
    ReplaceAll: 'REPLACE_ALL',
    DoNotReplace: 'DO_NOT_REPLACE',
    ReplaceMissingValuesOnly: 'REPLACE_MISSING_VALUES_ONLY',
    ReplaceWithNonMissing: 'REPLACE_WITH_NON_MISSING',
    DeleteInsert: 'DELETE_INSERT'
} as const;

export type StoreRule = typeof StoreRule[keyof typeof StoreRule];


/**
 * 
 * @export
 * @interface Stream
 */
export interface Stream {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof Stream
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof Stream
     */
    'stream-name'?: string;
    /**
     * 
     * @type {Array<Stream>}
     * @memberof Stream
     */
    'tributaries'?: Array<Stream>;
    /**
     * 
     * @type {Array<StreamReach>}
     * @memberof Stream
     */
    'stream-reaches'?: Array<StreamReach>;
    /**
     * 
     * @type {string}
     * @memberof Stream
     */
    'diverting-stream-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Stream
     */
    'receiving-stream-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Stream
     */
    'confluence-bank'?: string;
    /**
     * 
     * @type {string}
     * @memberof Stream
     */
    'diversion-bank'?: string;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    'stream-length'?: number;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    'confluence-station'?: number;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    'diversion-station'?: number;
    /**
     * 
     * @type {Array<StreamLocation>}
     * @memberof Stream
     */
    'stream-locations'?: Array<StreamLocation>;
    /**
     * 
     * @type {string}
     * @memberof Stream
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof Stream
     */
    'average-slope'?: number;
}
/**
 * 
 * @export
 * @interface StreamLocation
 */
export interface StreamLocation {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof StreamLocation
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof StreamLocation
     */
    'location-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamLocation
     */
    'stream-name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StreamLocation
     */
    'station'?: number;
    /**
     * 
     * @type {string}
     * @memberof StreamLocation
     */
    'bank'?: string;
    /**
     * 
     * @type {number}
     * @memberof StreamLocation
     */
    'published-station'?: number;
    /**
     * 
     * @type {number}
     * @memberof StreamLocation
     */
    'lowest-measurable-stage'?: number;
    /**
     * 
     * @type {number}
     * @memberof StreamLocation
     */
    'total-drainage-area'?: number;
    /**
     * 
     * @type {number}
     * @memberof StreamLocation
     */
    'ungaged-drainage-area'?: number;
    /**
     * 
     * @type {number}
     * @memberof StreamLocation
     */
    'nagivation-station'?: number;
}
/**
 * 
 * @export
 * @interface StreamReach
 */
export interface StreamReach {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof StreamReach
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof StreamReach
     */
    'upstream-location-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamReach
     */
    'downstream-location-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamReach
     */
    'stream-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamReach
     */
    'reach-name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamReach
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamReach
     */
    'configuration'?: string;
}
/**
 * Single Office or List of Offices in tab separated format
 * @export
 * @interface TabV1Office
 */
export interface TabV1Office {
    /**
     * 
     * @type {string}
     * @memberof TabV1Office
     */
    'Office'?: string;
    /**
     * 
     * @type {string}
     * @memberof TabV1Office
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TabV1Office
     */
    'officeType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TabV1Office
     */
    'reportsToOffice'?: string;
}
/**
 * 
 * @export
 * @interface TableRating
 */
export interface TableRating extends AbstractRatingMetadata {
    /**
     * 
     * @type {string}
     * @memberof TableRating
     */
    'in-range-method'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableRating
     */
    'out-range-low-method'?: string;
    /**
     * 
     * @type {string}
     * @memberof TableRating
     */
    'out-range-high-method'?: string;
}
/**
 * 
 * @export
 * @interface TimeSeries
 */
export interface TimeSeries {
    /**
     * The requested start time of the data, in ISO-8601 format with offset and timezone (\'yyyy-MM-dd\'T\'HH:mm:ssZ\'[\'VV\']\'\')
     * @type {string}
     * @memberof TimeSeries
     */
    'begin'?: string;
    /**
     * The requested end time of the data, in ISO-8601 format with offset and timezone (\'yyyy-MM-dd\'T\'HH:mm:ssZ\'[\'VV\']\'\')
     * @type {string}
     * @memberof TimeSeries
     */
    'end'?: string;
    /**
     * 
     * @type {TimeSeriesInterval}
     * @memberof TimeSeries
     */
    'interval'?: TimeSeriesInterval;
    /**
     * Offset from top of interval
     * @type {number}
     * @memberof TimeSeries
     */
    'interval-offset'?: number;
    /**
     * Time-series name
     * @type {string}
     * @memberof TimeSeries
     */
    'name'?: string;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof TimeSeries
     */
    'next-page'?: string;
    /**
     * Office ID that owns the time-series
     * @type {string}
     * @memberof TimeSeries
     */
    'office-id'?: string;
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof TimeSeries
     */
    'page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof TimeSeries
     */
    'page-size'?: number;
    /**
     * Only on 21.1.1 Database. The timezone the Interval Offset is from.
     * @type {string}
     * @memberof TimeSeries
     */
    'time-zone'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof TimeSeries
     */
    'total'?: number;
    /**
     * The units of the time series data
     * @type {string}
     * @memberof TimeSeries
     */
    'units': string;
    /**
     * 
     * @type {Array<TimeSeriesColumn>}
     * @memberof TimeSeries
     */
    'value-columns'?: Array<TimeSeriesColumn>;
    /**
     * 
     * @type {Array<Array<TimeSeriesValuesInnerInner>>}
     * @memberof TimeSeries
     */
    'values'?: Array<Array<TimeSeriesValuesInnerInner>>;
    /**
     * 
     * @type {VerticalDatumInfo}
     * @memberof TimeSeries
     */
    'vertical-datum-info'?: VerticalDatumInfo;
}
/**
 * A representation of a TimeSeries category
 * @export
 * @interface TimeSeriesCategory
 */
export interface TimeSeriesCategory {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof TimeSeriesCategory
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesCategory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesCategory
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface TimeSeriesColumn
 */
export interface TimeSeriesColumn {
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesColumn
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesColumn
     */
    'ordinal'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesColumn
     */
    'datatype'?: string;
}
/**
 * TimeSeries extent information
 * @export
 * @interface TimeSeriesExtents
 */
export interface TimeSeriesExtents {
    /**
     * Earliest value in the timeseries
     * @type {string}
     * @memberof TimeSeriesExtents
     */
    'earliest-time'?: string;
    /**
     * Last update in the timeseries
     * @type {string}
     * @memberof TimeSeriesExtents
     */
    'last-update'?: string;
    /**
     * Latest value in the timeseries
     * @type {string}
     * @memberof TimeSeriesExtents
     */
    'latest-time'?: string;
    /**
     * TimeSeries version to which this extent information applies
     * @type {string}
     * @memberof TimeSeriesExtents
     */
    'version-time'?: string;
}
/**
 * A representation of a timeseries group
 * @export
 * @interface TimeSeriesGroup
 */
export interface TimeSeriesGroup {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof TimeSeriesGroup
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesGroup
     */
    'id'?: string;
    /**
     * 
     * @type {TimeSeriesCategory}
     * @memberof TimeSeriesGroup
     */
    'time-series-category'?: TimeSeriesCategory;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesGroup
     */
    'shared-alias-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesGroup
     */
    'shared-ref-ts-id'?: string;
    /**
     * 
     * @type {Array<AssignedTimeSeries>}
     * @memberof TimeSeriesGroup
     */
    'assigned-time-series'?: Array<AssignedTimeSeries>;
}
/**
 * 
 * @export
 * @interface TimeSeriesIdentifierDescriptor
 */
export interface TimeSeriesIdentifierDescriptor {
    /**
     * Owning office of object.
     * @type {string}
     * @memberof TimeSeriesIdentifierDescriptor
     */
    'office-id': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesIdentifierDescriptor
     */
    'time-series-id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesIdentifierDescriptor
     */
    'timezone-name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesIdentifierDescriptor
     */
    'interval-offset-minutes'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesIdentifierDescriptor
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface TimeSeriesIdentifierDescriptors
 */
export interface TimeSeriesIdentifierDescriptors {
    /**
     * The cursor to the current page of data
     * @type {string}
     * @memberof TimeSeriesIdentifierDescriptors
     */
    'page'?: string;
    /**
     * The total number of records retrieved; null or not present if not supported or unknown
     * @type {number}
     * @memberof TimeSeriesIdentifierDescriptors
     */
    'total'?: number;
    /**
     * 
     * @type {Array<TimeSeriesIdentifierDescriptor>}
     * @memberof TimeSeriesIdentifierDescriptors
     */
    'descriptors'?: Array<TimeSeriesIdentifierDescriptor>;
    /**
     * The cursor to the next page of data; null if there is no more data
     * @type {string}
     * @memberof TimeSeriesIdentifierDescriptors
     */
    'next-page'?: string;
    /**
     * The number of records fetched per-page; this may be larger than the number of records actually retrieved
     * @type {number}
     * @memberof TimeSeriesIdentifierDescriptors
     */
    'page-size'?: number;
}
/**
 * The interval of the time-series, in ISO-8601 duration format
 * @export
 * @interface TimeSeriesInterval
 */
export interface TimeSeriesInterval {
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesInterval
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesInterval
     */
    'nano'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesInterval
     */
    'zero'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesInterval
     */
    'negative'?: boolean;
    /**
     * 
     * @type {Array<TimeSeriesIntervalUnitsInner>}
     * @memberof TimeSeriesInterval
     */
    'units'?: Array<TimeSeriesIntervalUnitsInner>;
}
/**
 * 
 * @export
 * @interface TimeSeriesIntervalUnitsInner
 */
export interface TimeSeriesIntervalUnitsInner {
    /**
     * 
     * @type {TimeSeriesIntervalUnitsInnerDuration}
     * @memberof TimeSeriesIntervalUnitsInner
     */
    'duration'?: TimeSeriesIntervalUnitsInnerDuration;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesIntervalUnitsInner
     */
    'durationEstimated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesIntervalUnitsInner
     */
    'dateBased'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesIntervalUnitsInner
     */
    'timeBased'?: boolean;
}
/**
 * 
 * @export
 * @interface TimeSeriesIntervalUnitsInnerDuration
 */
export interface TimeSeriesIntervalUnitsInnerDuration {
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesIntervalUnitsInnerDuration
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesIntervalUnitsInnerDuration
     */
    'nano'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesIntervalUnitsInnerDuration
     */
    'zero'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSeriesIntervalUnitsInnerDuration
     */
    'negative'?: boolean;
}
/**
 * List of retrieved time-series values
 * @export
 * @interface TimeSeriesRecord
 */
export interface TimeSeriesRecord {
    /**
     * Milliseconds since 1970-01-01 (Unix Epoch), always UTC
     * @type {number}
     * @memberof TimeSeriesRecord
     */
    'date-time'?: number;
    /**
     * Requested time-series data value
     * @type {number}
     * @memberof TimeSeriesRecord
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesRecord
     */
    'quality-code'?: number;
}
/**
 * List of retrieved time-series values
 * @export
 * @interface TimeSeriesValuesInnerInner
 */
export interface TimeSeriesValuesInnerInner {
    /**
     * Milliseconds since 1970-01-01 (Unix Epoch), always UTC
     * @type {number}
     * @memberof TimeSeriesValuesInnerInner
     */
    'date-time'?: number;
    /**
     * Requested time-series data value
     * @type {number}
     * @memberof TimeSeriesValuesInnerInner
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesValuesInnerInner
     */
    'quality-code'?: number;
}
/**
 * 
 * @export
 * @interface TimeseriesCatalogEntry
 */
export interface TimeseriesCatalogEntry {
    /**
     * 
     * @type {string}
     * @memberof TimeseriesCatalogEntry
     */
    'office'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeseriesCatalogEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeseriesCatalogEntry
     */
    'units'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeseriesCatalogEntry
     */
    'interval'?: string;
    /**
     * Offset from top of interval
     * @type {number}
     * @memberof TimeseriesCatalogEntry
     */
    'intervalOffset'?: number;
    /**
     * Only on 21.1.1 Database. The timezone the Interval Offset is from.
     * @type {string}
     * @memberof TimeseriesCatalogEntry
     */
    'timeZone'?: string;
    /**
     * 
     * @type {Array<TimeSeriesExtents>}
     * @memberof TimeseriesCatalogEntry
     */
    'extents'?: Array<TimeSeriesExtents>;
}
/**
 * 
 * @export
 * @interface TransitionalRating
 */
export interface TransitionalRating extends AbstractRatingMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof TransitionalRating
     */
    'source-ratings'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransitionalRating
     */
    'conditions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransitionalRating
     */
    'evaluations'?: Array<string>;
}
/**
 * Unit System desired in response. Can be SI (International Scientific) or EN (Imperial.) If unspecified, defaults to SI.
 * @export
 * @enum {string}
 */

export const UnitSystem = {
    Si: 'SI',
    En: 'EN'
} as const;

export type UnitSystem = typeof UnitSystem[keyof typeof UnitSystem];


/**
 * 
 * @export
 * @interface UsgsStreamRating
 */
export interface UsgsStreamRating extends TableRating {
}
/**
 * 
 * @export
 * @interface VerticalDatumInfo
 */
export interface VerticalDatumInfo {
    /**
     * 
     * @type {string}
     * @memberof VerticalDatumInfo
     */
    'office'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerticalDatumInfo
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerticalDatumInfo
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerticalDatumInfo
     */
    'native-datum'?: string;
    /**
     * 
     * @type {number}
     * @memberof VerticalDatumInfo
     */
    'elevation'?: number;
    /**
     * 
     * @type {Array<Offset>}
     * @memberof VerticalDatumInfo
     */
    'offsets'?: Array<Offset>;
}
/**
 * 
 * @export
 * @interface VirtualRating
 */
export interface VirtualRating extends AbstractRatingMetadata {
    /**
     * 
     * @type {Array<object>}
     * @memberof VirtualRating
     */
    'source-ratings'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof VirtualRating
     */
    'connections'?: string;
}

/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete API key for a user
         * @summary Delete cwmsData auth keys with keyName
         * @param {string} keyName 
         * @param {ApiKey} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataAuthKeysWithKeyName: async (keyName: string, apiKey?: ApiKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            assertParamExists('deleteCwmsDataAuthKeysWithKeyName', 'keyName', keyName)
            const localVarPath = `/cwms-data/auth/keys/{key-name}`
                .replace(`{${"key-name"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View all keys for the current user
         * @summary Get cwmsData auth keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataAuthKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/auth/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View specific key
         * @summary Get cwmsData auth keys with keyName
         * @param {string} keyName Name of the specific key to get more information for. NOTE: Case-sensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataAuthKeysWithKeyName: async (keyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            assertParamExists('getCwmsDataAuthKeysWithKeyName', 'keyName', keyName)
            const localVarPath = `/cwms-data/auth/keys/{key-name}`
                .replace(`{${"key-name"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API Key for user. The randomly generated key is returned to the caller. A provided key will be ignored.
         * @summary Post cwmsData auth keys
         * @param {ApiKey} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataAuthKeys: async (apiKey?: ApiKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/auth/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete API key for a user
         * @summary Delete cwmsData auth keys with keyName
         * @param {string} keyName 
         * @param {ApiKey} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataAuthKeysWithKeyName(keyName: string, apiKey?: ApiKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataAuthKeysWithKeyName(keyName, apiKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.deleteCwmsDataAuthKeysWithKeyName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * View all keys for the current user
         * @summary Get cwmsData auth keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataAuthKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataAuthKeys(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.getCwmsDataAuthKeys']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * View specific key
         * @summary Get cwmsData auth keys with keyName
         * @param {string} keyName Name of the specific key to get more information for. NOTE: Case-sensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataAuthKeysWithKeyName(keyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataAuthKeysWithKeyName(keyName, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.getCwmsDataAuthKeysWithKeyName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new API Key for user. The randomly generated key is returned to the caller. A provided key will be ignored.
         * @summary Post cwmsData auth keys
         * @param {ApiKey} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataAuthKeys(apiKey?: ApiKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataAuthKeys(apiKey, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.postCwmsDataAuthKeys']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizationApiFp(configuration)
    return {
        /**
         * Delete API key for a user
         * @summary Delete cwmsData auth keys with keyName
         * @param {string} keyName 
         * @param {ApiKey} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataAuthKeysWithKeyName(keyName: string, apiKey?: ApiKey, options?: any): AxiosPromise<ApiKey> {
            return localVarFp.deleteCwmsDataAuthKeysWithKeyName(keyName, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * View all keys for the current user
         * @summary Get cwmsData auth keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataAuthKeys(options?: any): AxiosPromise<Array<ApiKey>> {
            return localVarFp.getCwmsDataAuthKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * View specific key
         * @summary Get cwmsData auth keys with keyName
         * @param {string} keyName Name of the specific key to get more information for. NOTE: Case-sensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataAuthKeysWithKeyName(keyName: string, options?: any): AxiosPromise<ApiKey> {
            return localVarFp.getCwmsDataAuthKeysWithKeyName(keyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API Key for user. The randomly generated key is returned to the caller. A provided key will be ignored.
         * @summary Post cwmsData auth keys
         * @param {ApiKey} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataAuthKeys(apiKey?: ApiKey, options?: any): AxiosPromise<ApiKey> {
            return localVarFp.postCwmsDataAuthKeys(apiKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * Delete API key for a user
     * @summary Delete cwmsData auth keys with keyName
     * @param {string} keyName 
     * @param {ApiKey} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public deleteCwmsDataAuthKeysWithKeyName(keyName: string, apiKey?: ApiKey, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).deleteCwmsDataAuthKeysWithKeyName(keyName, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View all keys for the current user
     * @summary Get cwmsData auth keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getCwmsDataAuthKeys(options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).getCwmsDataAuthKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View specific key
     * @summary Get cwmsData auth keys with keyName
     * @param {string} keyName Name of the specific key to get more information for. NOTE: Case-sensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getCwmsDataAuthKeysWithKeyName(keyName: string, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).getCwmsDataAuthKeysWithKeyName(keyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new API Key for user. The randomly generated key is returned to the caller. A provided key will be ignored.
     * @summary Post cwmsData auth keys
     * @param {ApiKey} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public postCwmsDataAuthKeys(apiKey?: ApiKey, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).postCwmsDataAuthKeys(apiKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BasinsApi - axios parameter creator
 * @export
 */
export const BasinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns CWMS Basin Data
         * @summary Get cwmsData basins
         * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBasins: async (office?: string, unit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/basins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS Basin Data
         * @summary Get cwmsData basins with basinId
         * @param {string} basinId 
         * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBasinsWithBasinId: async (basinId: string, office?: string, unit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'basinId' is not null or undefined
            assertParamExists('getCwmsDataBasinsWithBasinId', 'basinId', basinId)
            const localVarPath = `/cwms-data/basins/{basin-id}`
                .replace(`{${"basin-id"}}`, encodeURIComponent(String(basinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasinsApi - functional programming interface
 * @export
 */
export const BasinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasinsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns CWMS Basin Data
         * @summary Get cwmsData basins
         * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataBasins(office?: string, unit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Basin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataBasins(office, unit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasinsApi.getCwmsDataBasins']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS Basin Data
         * @summary Get cwmsData basins with basinId
         * @param {string} basinId 
         * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataBasinsWithBasinId(basinId: string, office?: string, unit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Basin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataBasinsWithBasinId(basinId, office, unit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BasinsApi.getCwmsDataBasinsWithBasinId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BasinsApi - factory interface
 * @export
 */
export const BasinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasinsApiFp(configuration)
    return {
        /**
         * Returns CWMS Basin Data
         * @summary Get cwmsData basins
         * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBasins(office?: string, unit?: string, options?: any): AxiosPromise<Basin> {
            return localVarFp.getCwmsDataBasins(office, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS Basin Data
         * @summary Get cwmsData basins with basinId
         * @param {string} basinId 
         * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBasinsWithBasinId(basinId: string, office?: string, unit?: string, options?: any): AxiosPromise<Basin> {
            return localVarFp.getCwmsDataBasinsWithBasinId(basinId, office, unit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasinsApi - object-oriented interface
 * @export
 * @class BasinsApi
 * @extends {BaseAPI}
 */
export class BasinsApi extends BaseAPI {
    /**
     * Returns CWMS Basin Data
     * @summary Get cwmsData basins
     * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
     * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasinsApi
     */
    public getCwmsDataBasins(office?: string, unit?: string, options?: RawAxiosRequestConfig) {
        return BasinsApiFp(this.configuration).getCwmsDataBasins(office, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS Basin Data
     * @summary Get cwmsData basins with basinId
     * @param {string} basinId 
     * @param {string} [office] Specifies the owning office of the basin whose data is to be included in the response. If this field is not specified, matching basin information from all offices shall be returned.
     * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system. Basin values will be in the default English units for their parameters. (This is default if no value is entered)  2. SI.   Specifies the SI unit system. Basin values will be in the default SI units for their parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasinsApi
     */
    public getCwmsDataBasinsWithBasinId(basinId: string, office?: string, unit?: string, options?: RawAxiosRequestConfig) {
        return BasinsApiFp(this.configuration).getCwmsDataBasinsWithBasinId(basinId, office, unit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlobApi - axios parameter creator
 * @export
 */
export const BlobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData blobs
         * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 20.
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; describing the blob id\&#39;s you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBlobs: async (office?: string, page?: string, pageSize?: number, like?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/blobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (like !== undefined) {
                localVarQueryParameter['like'] = like;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData blobs with blobId
         * @param {string} blobId 
         * @param {string} [office] Specifies the owning office.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBlobsWithBlobId: async (blobId: string, office?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blobId' is not null or undefined
            assertParamExists('getCwmsDataBlobsWithBlobId', 'blobId', blobId)
            const localVarPath = `/cwms-data/blobs/{blob-id}`
                .replace(`{${"blob-id"}}`, encodeURIComponent(String(blobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlobApi - functional programming interface
 * @export
 */
export const BlobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData blobs
         * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 20.
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; describing the blob id\&#39;s you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataBlobs(office?: string, page?: string, pageSize?: number, like?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blobs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataBlobs(office, page, pageSize, like, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BlobApi.getCwmsDataBlobs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData blobs with blobId
         * @param {string} blobId 
         * @param {string} [office] Specifies the owning office.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataBlobsWithBlobId(blobId: string, office?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataBlobsWithBlobId(blobId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['BlobApi.getCwmsDataBlobsWithBlobId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * BlobApi - factory interface
 * @export
 */
export const BlobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlobApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData blobs
         * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 20.
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; describing the blob id\&#39;s you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBlobs(office?: string, page?: string, pageSize?: number, like?: string, options?: any): AxiosPromise<Blobs> {
            return localVarFp.getCwmsDataBlobs(office, page, pageSize, like, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData blobs with blobId
         * @param {string} blobId 
         * @param {string} [office] Specifies the owning office.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataBlobsWithBlobId(blobId: string, office?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCwmsDataBlobsWithBlobId(blobId, office, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlobApi - object-oriented interface
 * @export
 * @class BlobApi
 * @extends {BaseAPI}
 */
export class BlobApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData blobs
     * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 20.
     * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; describing the blob id\&#39;s you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobApi
     */
    public getCwmsDataBlobs(office?: string, page?: string, pageSize?: number, like?: string, options?: RawAxiosRequestConfig) {
        return BlobApiFp(this.configuration).getCwmsDataBlobs(office, page, pageSize, like, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData blobs with blobId
     * @param {string} blobId 
     * @param {string} [office] Specifies the owning office.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobApi
     */
    public getCwmsDataBlobsWithBlobId(blobId: string, office?: string, options?: RawAxiosRequestConfig) {
        return BlobApiFp(this.configuration).getCwmsDataBlobsWithBlobId(blobId, office, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CatalogApi - axios parameter creator
 * @export
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData catalog with dataset
         * @param {CatalogableEndpoint} dataset A list of what data? E.g. Timeseries, Locations, Ratings, etc
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are.
         * @param {number} [pageSize] How many entires per page returned. Default 500.
         * @param {UnitSystem} [unitSystem] Unit System desired in response. Can be SI (International Scientific) or EN (Imperial.) If unspecified, defaults to SI.
         * @param {string} [office] 3-4 letter office name representing the district you want to isolate data to.
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
         * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
         * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
         * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
         * @param {string} [locationGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location group id
         * @param {string} [boundingOfficeLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location bounding office. When this field is used items with no bounding office set will not be present in results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataCatalogWithDataset: async (dataset: CatalogableEndpoint, page?: string, pageSize?: number, unitSystem?: UnitSystem, office?: string, like?: string, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, locationCategoryLike?: string, locationGroupLike?: string, boundingOfficeLike?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('getCwmsDataCatalogWithDataset', 'dataset', dataset)
            const localVarPath = `/cwms-data/catalog/{dataset}`
                .replace(`{${"dataset"}}`, encodeURIComponent(String(dataset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (unitSystem !== undefined) {
                localVarQueryParameter['unit-system'] = unitSystem;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (like !== undefined) {
                localVarQueryParameter['like'] = like;
            }

            if (timeseriesCategoryLike !== undefined) {
                localVarQueryParameter['timeseries-category-like'] = timeseriesCategoryLike;
            }

            if (timeseriesGroupLike !== undefined) {
                localVarQueryParameter['timeseries-group-like'] = timeseriesGroupLike;
            }

            if (locationCategoryLike !== undefined) {
                localVarQueryParameter['location-category-like'] = locationCategoryLike;
            }

            if (locationGroupLike !== undefined) {
                localVarQueryParameter['location-group-like'] = locationGroupLike;
            }

            if (boundingOfficeLike !== undefined) {
                localVarQueryParameter['bounding-office-like'] = boundingOfficeLike;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogApi - functional programming interface
 * @export
 */
export const CatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData catalog with dataset
         * @param {CatalogableEndpoint} dataset A list of what data? E.g. Timeseries, Locations, Ratings, etc
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are.
         * @param {number} [pageSize] How many entires per page returned. Default 500.
         * @param {UnitSystem} [unitSystem] Unit System desired in response. Can be SI (International Scientific) or EN (Imperial.) If unspecified, defaults to SI.
         * @param {string} [office] 3-4 letter office name representing the district you want to isolate data to.
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
         * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
         * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
         * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
         * @param {string} [locationGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location group id
         * @param {string} [boundingOfficeLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location bounding office. When this field is used items with no bounding office set will not be present in results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataCatalogWithDataset(dataset: CatalogableEndpoint, page?: string, pageSize?: number, unitSystem?: UnitSystem, office?: string, like?: string, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, locationCategoryLike?: string, locationGroupLike?: string, boundingOfficeLike?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Catalog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataCatalogWithDataset(dataset, page, pageSize, unitSystem, office, like, timeseriesCategoryLike, timeseriesGroupLike, locationCategoryLike, locationGroupLike, boundingOfficeLike, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CatalogApi.getCwmsDataCatalogWithDataset']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CatalogApi - factory interface
 * @export
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData catalog with dataset
         * @param {CatalogableEndpoint} dataset A list of what data? E.g. Timeseries, Locations, Ratings, etc
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are.
         * @param {number} [pageSize] How many entires per page returned. Default 500.
         * @param {UnitSystem} [unitSystem] Unit System desired in response. Can be SI (International Scientific) or EN (Imperial.) If unspecified, defaults to SI.
         * @param {string} [office] 3-4 letter office name representing the district you want to isolate data to.
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
         * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
         * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
         * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
         * @param {string} [locationGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location group id
         * @param {string} [boundingOfficeLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location bounding office. When this field is used items with no bounding office set will not be present in results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataCatalogWithDataset(dataset: CatalogableEndpoint, page?: string, pageSize?: number, unitSystem?: UnitSystem, office?: string, like?: string, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, locationCategoryLike?: string, locationGroupLike?: string, boundingOfficeLike?: string, options?: any): AxiosPromise<Catalog> {
            return localVarFp.getCwmsDataCatalogWithDataset(dataset, page, pageSize, unitSystem, office, like, timeseriesCategoryLike, timeseriesGroupLike, locationCategoryLike, locationGroupLike, boundingOfficeLike, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
export class CatalogApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData catalog with dataset
     * @param {CatalogableEndpoint} dataset A list of what data? E.g. Timeseries, Locations, Ratings, etc
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are.
     * @param {number} [pageSize] How many entires per page returned. Default 500.
     * @param {UnitSystem} [unitSystem] Unit System desired in response. Can be SI (International Scientific) or EN (Imperial.) If unspecified, defaults to SI.
     * @param {string} [office] 3-4 letter office name representing the district you want to isolate data to.
     * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
     * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
     * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
     * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
     * @param {string} [locationGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location group id
     * @param {string} [boundingOfficeLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location bounding office. When this field is used items with no bounding office set will not be present in results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getCwmsDataCatalogWithDataset(dataset: CatalogableEndpoint, page?: string, pageSize?: number, unitSystem?: UnitSystem, office?: string, like?: string, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, locationCategoryLike?: string, locationGroupLike?: string, boundingOfficeLike?: string, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getCwmsDataCatalogWithDataset(dataset, page, pageSize, unitSystem, office, like, timeseriesCategoryLike, timeseriesGroupLike, locationCategoryLike, locationGroupLike, boundingOfficeLike, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClobApi - axios parameter creator
 * @export
 */
export const ClobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete clob
         * @summary Delete cwmsData clobs with clobId
         * @param {string} clobId Specifies the id of the clob to be deleted
         * @param {string} office Specifies the office of the clob.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataClobsWithClobId: async (clobId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clobId' is not null or undefined
            assertParamExists('deleteCwmsDataClobsWithClobId', 'clobId', clobId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataClobsWithClobId', 'office', office)
            const localVarPath = `/cwms-data/clobs/{clob-id}`
                .replace(`{${"clob-id"}}`, encodeURIComponent(String(clobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData clobs
         * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 20.
         * @param {boolean} [includeValues] Do you want the value associated with this particular clob (default: false)
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataClobs: async (office?: string, page?: string, pageSize?: number, includeValues?: boolean, like?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/clobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (includeValues !== undefined) {
                localVarQueryParameter['include-values'] = includeValues;
            }

            if (like !== undefined) {
                localVarQueryParameter['like'] = like;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData clobs with clobId
         * @param {string} clobId 
         * @param {string} [office] Specifies the owning office.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataClobsWithClobId: async (clobId: string, office?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clobId' is not null or undefined
            assertParamExists('getCwmsDataClobsWithClobId', 'clobId', clobId)
            const localVarPath = `/cwms-data/clobs/{clob-id}`
                .replace(`{${"clob-id"}}`, encodeURIComponent(String(clobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update clob
         * @summary Patch cwmsData clobs with clobId
         * @param {string} clobId Specifies the id of the clob to be updated
         * @param {Clob} clob 
         * @param {boolean} [ignoreNulls] If true, null and empty fields in the provided clob will be ignored and the existing value of those fields left in place. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataClobsWithClobId: async (clobId: string, clob: Clob, ignoreNulls?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clobId' is not null or undefined
            assertParamExists('patchCwmsDataClobsWithClobId', 'clobId', clobId)
            // verify required parameter 'clob' is not null or undefined
            assertParamExists('patchCwmsDataClobsWithClobId', 'clob', clob)
            const localVarPath = `/cwms-data/clobs/{clob-id}`
                .replace(`{${"clob-id"}}`, encodeURIComponent(String(clobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (ignoreNulls !== undefined) {
                localVarQueryParameter['ignore-nulls'] = ignoreNulls;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new Clob
         * @summary Post cwmsData clobs
         * @param {Clob} clob 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataClobs: async (clob: Clob, failIfExists?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clob' is not null or undefined
            assertParamExists('postCwmsDataClobs', 'clob', clob)
            const localVarPath = `/cwms-data/clobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (failIfExists !== undefined) {
                localVarQueryParameter['fail-if-exists'] = failIfExists;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clob, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClobApi - functional programming interface
 * @export
 */
export const ClobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClobApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete clob
         * @summary Delete cwmsData clobs with clobId
         * @param {string} clobId Specifies the id of the clob to be deleted
         * @param {string} office Specifies the office of the clob.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataClobsWithClobId(clobId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataClobsWithClobId(clobId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ClobApi.deleteCwmsDataClobsWithClobId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData clobs
         * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 20.
         * @param {boolean} [includeValues] Do you want the value associated with this particular clob (default: false)
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataClobs(office?: string, page?: string, pageSize?: number, includeValues?: boolean, like?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Clobs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataClobs(office, page, pageSize, includeValues, like, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ClobApi.getCwmsDataClobs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData clobs with clobId
         * @param {string} clobId 
         * @param {string} [office] Specifies the owning office.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataClobsWithClobId(clobId: string, office?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Clob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataClobsWithClobId(clobId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ClobApi.getCwmsDataClobsWithClobId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update clob
         * @summary Patch cwmsData clobs with clobId
         * @param {string} clobId Specifies the id of the clob to be updated
         * @param {Clob} clob 
         * @param {boolean} [ignoreNulls] If true, null and empty fields in the provided clob will be ignored and the existing value of those fields left in place. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataClobsWithClobId(clobId: string, clob: Clob, ignoreNulls?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataClobsWithClobId(clobId, clob, ignoreNulls, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ClobApi.patchCwmsDataClobsWithClobId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new Clob
         * @summary Post cwmsData clobs
         * @param {Clob} clob 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataClobs(clob: Clob, failIfExists?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataClobs(clob, failIfExists, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ClobApi.postCwmsDataClobs']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ClobApi - factory interface
 * @export
 */
export const ClobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClobApiFp(configuration)
    return {
        /**
         * Delete clob
         * @summary Delete cwmsData clobs with clobId
         * @param {string} clobId Specifies the id of the clob to be deleted
         * @param {string} office Specifies the office of the clob.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataClobsWithClobId(clobId: string, office: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataClobsWithClobId(clobId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData clobs
         * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 20.
         * @param {boolean} [includeValues] Do you want the value associated with this particular clob (default: false)
         * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataClobs(office?: string, page?: string, pageSize?: number, includeValues?: boolean, like?: string, options?: any): AxiosPromise<Clobs> {
            return localVarFp.getCwmsDataClobs(office, page, pageSize, includeValues, like, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData clobs with clobId
         * @param {string} clobId 
         * @param {string} [office] Specifies the owning office.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataClobsWithClobId(clobId: string, office?: string, options?: any): AxiosPromise<Clob> {
            return localVarFp.getCwmsDataClobsWithClobId(clobId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * Update clob
         * @summary Patch cwmsData clobs with clobId
         * @param {string} clobId Specifies the id of the clob to be updated
         * @param {Clob} clob 
         * @param {boolean} [ignoreNulls] If true, null and empty fields in the provided clob will be ignored and the existing value of those fields left in place. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataClobsWithClobId(clobId: string, clob: Clob, ignoreNulls?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataClobsWithClobId(clobId, clob, ignoreNulls, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new Clob
         * @summary Post cwmsData clobs
         * @param {Clob} clob 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataClobs(clob: Clob, failIfExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataClobs(clob, failIfExists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClobApi - object-oriented interface
 * @export
 * @class ClobApi
 * @extends {BaseAPI}
 */
export class ClobApi extends BaseAPI {
    /**
     * Delete clob
     * @summary Delete cwmsData clobs with clobId
     * @param {string} clobId Specifies the id of the clob to be deleted
     * @param {string} office Specifies the office of the clob.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClobApi
     */
    public deleteCwmsDataClobsWithClobId(clobId: string, office: string, options?: RawAxiosRequestConfig) {
        return ClobApiFp(this.configuration).deleteCwmsDataClobsWithClobId(clobId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData clobs
     * @param {string} [office] Specifies the owning office. If this field is not specified, matching information from all offices shall be returned.
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 20.
     * @param {boolean} [includeValues] Do you want the value associated with this particular clob (default: false)
     * @param {string} [like] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClobApi
     */
    public getCwmsDataClobs(office?: string, page?: string, pageSize?: number, includeValues?: boolean, like?: string, options?: RawAxiosRequestConfig) {
        return ClobApiFp(this.configuration).getCwmsDataClobs(office, page, pageSize, includeValues, like, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData clobs with clobId
     * @param {string} clobId 
     * @param {string} [office] Specifies the owning office.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClobApi
     */
    public getCwmsDataClobsWithClobId(clobId: string, office?: string, options?: RawAxiosRequestConfig) {
        return ClobApiFp(this.configuration).getCwmsDataClobsWithClobId(clobId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update clob
     * @summary Patch cwmsData clobs with clobId
     * @param {string} clobId Specifies the id of the clob to be updated
     * @param {Clob} clob 
     * @param {boolean} [ignoreNulls] If true, null and empty fields in the provided clob will be ignored and the existing value of those fields left in place. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClobApi
     */
    public patchCwmsDataClobsWithClobId(clobId: string, clob: Clob, ignoreNulls?: boolean, options?: RawAxiosRequestConfig) {
        return ClobApiFp(this.configuration).patchCwmsDataClobsWithClobId(clobId, clob, ignoreNulls, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new Clob
     * @summary Post cwmsData clobs
     * @param {Clob} clob 
     * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClobApi
     */
    public postCwmsDataClobs(clob: Clob, failIfExists?: boolean, options?: RawAxiosRequestConfig) {
        return ClobApiFp(this.configuration).postCwmsDataClobs(clob, failIfExists, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountiesApi - axios parameter creator
 * @export
 */
export const CountiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData counties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataCounties: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/counties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountiesApi - functional programming interface
 * @export
 */
export const CountiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData counties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataCounties(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<County>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataCounties(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CountiesApi.getCwmsDataCounties']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CountiesApi - factory interface
 * @export
 */
export const CountiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData counties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataCounties(options?: any): AxiosPromise<Array<County>> {
            return localVarFp.getCwmsDataCounties(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountiesApi - object-oriented interface
 * @export
 * @class CountiesApi
 * @extends {BaseAPI}
 */
export class CountiesApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData counties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountiesApi
     */
    public getCwmsDataCounties(options?: RawAxiosRequestConfig) {
        return CountiesApiFp(this.configuration).getCwmsDataCounties(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData levels with levelId timeseries
         * @param {string} levelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLevelsWithLevelIdTimeseries: async (levelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelId' is not null or undefined
            assertParamExists('getCwmsDataLevelsWithLevelIdTimeseries', 'levelId', levelId)
            const localVarPath = `/cwms-data/levels/{level-id}/timeseries`
                .replace(`{${"level-id"}}`, encodeURIComponent(String(levelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData timeseries recent with groupId
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesRecentWithGroupId: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesRecentWithGroupId', 'groupId', groupId)
            const localVarPath = `/cwms-data/timeseries/recent/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsData(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsData(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getCwmsData']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData levels with levelId timeseries
         * @param {string} levelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLevelsWithLevelIdTimeseries(levelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLevelsWithLevelIdTimeseries(levelId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getCwmsDataLevelsWithLevelIdTimeseries']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData timeseries recent with groupId
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseriesRecentWithGroupId(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseriesRecentWithGroupId(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getCwmsDataTimeseriesRecentWithGroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsData(options?: any): AxiosPromise<void> {
            return localVarFp.getCwmsData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData levels with levelId timeseries
         * @param {string} levelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLevelsWithLevelIdTimeseries(levelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCwmsDataLevelsWithLevelIdTimeseries(levelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData timeseries recent with groupId
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesRecentWithGroupId(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCwmsDataTimeseriesRecentWithGroupId(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCwmsData(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCwmsData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData levels with levelId timeseries
     * @param {string} levelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCwmsDataLevelsWithLevelIdTimeseries(levelId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCwmsDataLevelsWithLevelIdTimeseries(levelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData timeseries recent with groupId
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCwmsDataTimeseriesRecentWithGroupId(groupId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCwmsDataTimeseriesRecentWithGroupId(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LevelsApi - axios parameter creator
 * @export
 */
export const LevelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete CWMS Location Level
         * @summary Delete cwmsData levels with levelId
         * @param {string} levelId Specifies the location level id of the Location Level to be deleted
         * @param {boolean} [cascadeDelete] 
         * @param {string} [office] Specifies the owning office of the location level whose data is to be deleted. If this field is not specified, matching location level information will be deleted from all offices.
         * @param {string} [effectiveDate] Specifies the effective date of the level to be deleted. If not provided will delete all data and reference to the location level.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLevelsWithLevelId: async (levelId: string, cascadeDelete?: boolean, office?: string, effectiveDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelId' is not null or undefined
            assertParamExists('deleteCwmsDataLevelsWithLevelId', 'levelId', levelId)
            const localVarPath = `/cwms-data/levels/{level-id}`
                .replace(`{${"level-id"}}`, encodeURIComponent(String(levelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (cascadeDelete !== undefined) {
                localVarQueryParameter['cascade-delete'] = cascadeDelete;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective-date'] = effectiveDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes requested specified level id
         * @summary Delete cwmsData specifiedLevels with specifiedLevelId
         * @param {string} specifiedLevelId The specified level id to be deleted
         * @param {string} office Specifies the owning office of the timeseries identifier to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId: async (specifiedLevelId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'specifiedLevelId' is not null or undefined
            assertParamExists('deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId', 'specifiedLevelId', specifiedLevelId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId', 'office', office)
            const localVarPath = `/cwms-data/specified-levels/{specified-level-id}`
                .replace(`{${"specified-level-id"}}`, encodeURIComponent(String(specifiedLevelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData levels
         * @param {string} [levelIdMask] Specifies the name(s) of the location level(s) whose data is to be included in the response. Uses * for all.
         * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [format] Specifies the encoding format of the response. Requests specifying an Accept header:application/json;version&#x3D;2 must not include this field. Valid format field values for this URI are:  1.    tab  2.    csv  3.    xml  4.    wml2 (only if name field is specified)  5.    json (default)  
         * @param {string} [page] This identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLevels: async (levelIdMask?: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/levels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (levelIdMask !== undefined) {
                localVarQueryParameter['level-id-mask'] = levelIdMask;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (datum !== undefined) {
                localVarQueryParameter['datum'] = datum;
            }

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves requested Location Level
         * @summary Get cwmsData levels with levelId
         * @param {string} levelId Specifies the requested location level.
         * @param {string} office Specifies the office of the Location Level to be returned
         * @param {string} effectiveDate Specifies the effective date of Location Level to be returned
         * @param {string} [unit] Desired unit for the values retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLevelsWithLevelId: async (levelId: string, office: string, effectiveDate: string, unit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelId' is not null or undefined
            assertParamExists('getCwmsDataLevelsWithLevelId', 'levelId', levelId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataLevelsWithLevelId', 'office', office)
            // verify required parameter 'effectiveDate' is not null or undefined
            assertParamExists('getCwmsDataLevelsWithLevelId', 'effectiveDate', effectiveDate)
            const localVarPath = `/cwms-data/levels/{level-id}`
                .replace(`{${"level-id"}}`, encodeURIComponent(String(levelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective-date'] = effectiveDate;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData specifiedLevels
         * @param {string} [office] Specifies the owning office of the Specified Levels whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [templateIdMask] Mask that specifies the IDs to be included in the response. If this field is not specified, all specified levels shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataSpecifiedLevels: async (office?: string, templateIdMask?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/specified-levels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (templateIdMask !== undefined) {
                localVarQueryParameter['template-id-mask'] = templateIdMask;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CWMS Location Level
         * @summary Patch cwmsData levels with levelId
         * @param {string} levelId Specifies the location level id of the Location Level to be updated
         * @param {LocationLevel} locationLevel 
         * @param {string} [effectiveDate] Specifies the effective date of Location Level that will be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataLevelsWithLevelId: async (levelId: string, locationLevel: LocationLevel, effectiveDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'levelId' is not null or undefined
            assertParamExists('patchCwmsDataLevelsWithLevelId', 'levelId', levelId)
            // verify required parameter 'locationLevel' is not null or undefined
            assertParamExists('patchCwmsDataLevelsWithLevelId', 'locationLevel', locationLevel)
            const localVarPath = `/cwms-data/levels/{level-id}`
                .replace(`{${"level-id"}}`, encodeURIComponent(String(levelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (effectiveDate !== undefined) {
                localVarQueryParameter['effective-date'] = effectiveDate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationLevel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames the requested specified level id
         * @summary Patch cwmsData specifiedLevels with specifiedLevelId
         * @param {string} specifiedLevelId 
         * @param {string} specifiedLevelId2 The new specified level id.
         * @param {string} office Specifies the owning office of the specified level to be renamed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId: async (specifiedLevelId: string, specifiedLevelId2: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'specifiedLevelId' is not null or undefined
            assertParamExists('patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId', 'specifiedLevelId', specifiedLevelId)
            // verify required parameter 'specifiedLevelId2' is not null or undefined
            assertParamExists('patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId', 'specifiedLevelId2', specifiedLevelId2)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId', 'office', office)
            const localVarPath = `/cwms-data/specified-levels/{specified-level-id}`
                .replace(`{${"specified-level-id"}}`, encodeURIComponent(String(specifiedLevelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (specifiedLevelId2 !== undefined) {
                localVarQueryParameter['specified-level-id'] = specifiedLevelId2;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new CWMS Location Level
         * @summary Post cwmsData levels
         * @param {LocationLevel} locationLevel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLevels: async (locationLevel: LocationLevel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationLevel' is not null or undefined
            assertParamExists('postCwmsDataLevels', 'locationLevel', locationLevel)
            const localVarPath = `/cwms-data/levels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationLevel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new SpecifiedLevel
         * @summary Post cwmsData specifiedLevels
         * @param {SpecifiedLevel} specifiedLevel 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataSpecifiedLevels: async (specifiedLevel: SpecifiedLevel, failIfExists?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'specifiedLevel' is not null or undefined
            assertParamExists('postCwmsDataSpecifiedLevels', 'specifiedLevel', specifiedLevel)
            const localVarPath = `/cwms-data/specified-levels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (failIfExists !== undefined) {
                localVarQueryParameter['fail-if-exists'] = failIfExists;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specifiedLevel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LevelsApi - functional programming interface
 * @export
 */
export const LevelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LevelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete CWMS Location Level
         * @summary Delete cwmsData levels with levelId
         * @param {string} levelId Specifies the location level id of the Location Level to be deleted
         * @param {boolean} [cascadeDelete] 
         * @param {string} [office] Specifies the owning office of the location level whose data is to be deleted. If this field is not specified, matching location level information will be deleted from all offices.
         * @param {string} [effectiveDate] Specifies the effective date of the level to be deleted. If not provided will delete all data and reference to the location level.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataLevelsWithLevelId(levelId: string, cascadeDelete?: boolean, office?: string, effectiveDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataLevelsWithLevelId(levelId, cascadeDelete, office, effectiveDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.deleteCwmsDataLevelsWithLevelId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes requested specified level id
         * @summary Delete cwmsData specifiedLevels with specifiedLevelId
         * @param {string} specifiedLevelId The specified level id to be deleted
         * @param {string} office Specifies the owning office of the timeseries identifier to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData levels
         * @param {string} [levelIdMask] Specifies the name(s) of the location level(s) whose data is to be included in the response. Uses * for all.
         * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [format] Specifies the encoding format of the response. Requests specifying an Accept header:application/json;version&#x3D;2 must not include this field. Valid format field values for this URI are:  1.    tab  2.    csv  3.    xml  4.    wml2 (only if name field is specified)  5.    json (default)  
         * @param {string} [page] This identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLevels(levelIdMask?: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLevels(levelIdMask, office, unit, datum, begin, end, timezone, format, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.getCwmsDataLevels']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves requested Location Level
         * @summary Get cwmsData levels with levelId
         * @param {string} levelId Specifies the requested location level.
         * @param {string} office Specifies the office of the Location Level to be returned
         * @param {string} effectiveDate Specifies the effective date of Location Level to be returned
         * @param {string} [unit] Desired unit for the values retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLevelsWithLevelId(levelId: string, office: string, effectiveDate: string, unit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationLevel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLevelsWithLevelId(levelId, office, effectiveDate, unit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.getCwmsDataLevelsWithLevelId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData specifiedLevels
         * @param {string} [office] Specifies the owning office of the Specified Levels whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [templateIdMask] Mask that specifies the IDs to be included in the response. If this field is not specified, all specified levels shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataSpecifiedLevels(office?: string, templateIdMask?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecifiedLevel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataSpecifiedLevels(office, templateIdMask, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.getCwmsDataSpecifiedLevels']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update CWMS Location Level
         * @summary Patch cwmsData levels with levelId
         * @param {string} levelId Specifies the location level id of the Location Level to be updated
         * @param {LocationLevel} locationLevel 
         * @param {string} [effectiveDate] Specifies the effective date of Location Level that will be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataLevelsWithLevelId(levelId: string, locationLevel: LocationLevel, effectiveDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataLevelsWithLevelId(levelId, locationLevel, effectiveDate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.patchCwmsDataLevelsWithLevelId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Renames the requested specified level id
         * @summary Patch cwmsData specifiedLevels with specifiedLevelId
         * @param {string} specifiedLevelId 
         * @param {string} specifiedLevelId2 The new specified level id.
         * @param {string} office Specifies the owning office of the specified level to be renamed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId: string, specifiedLevelId2: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId, specifiedLevelId2, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new CWMS Location Level
         * @summary Post cwmsData levels
         * @param {LocationLevel} locationLevel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataLevels(locationLevel: LocationLevel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataLevels(locationLevel, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.postCwmsDataLevels']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new SpecifiedLevel
         * @summary Post cwmsData specifiedLevels
         * @param {SpecifiedLevel} specifiedLevel 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataSpecifiedLevels(specifiedLevel: SpecifiedLevel, failIfExists?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataSpecifiedLevels(specifiedLevel, failIfExists, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LevelsApi.postCwmsDataSpecifiedLevels']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LevelsApi - factory interface
 * @export
 */
export const LevelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LevelsApiFp(configuration)
    return {
        /**
         * Delete CWMS Location Level
         * @summary Delete cwmsData levels with levelId
         * @param {string} levelId Specifies the location level id of the Location Level to be deleted
         * @param {boolean} [cascadeDelete] 
         * @param {string} [office] Specifies the owning office of the location level whose data is to be deleted. If this field is not specified, matching location level information will be deleted from all offices.
         * @param {string} [effectiveDate] Specifies the effective date of the level to be deleted. If not provided will delete all data and reference to the location level.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLevelsWithLevelId(levelId: string, cascadeDelete?: boolean, office?: string, effectiveDate?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataLevelsWithLevelId(levelId, cascadeDelete, office, effectiveDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes requested specified level id
         * @summary Delete cwmsData specifiedLevels with specifiedLevelId
         * @param {string} specifiedLevelId The specified level id to be deleted
         * @param {string} office Specifies the owning office of the timeseries identifier to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId: string, office: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData levels
         * @param {string} [levelIdMask] Specifies the name(s) of the location level(s) whose data is to be included in the response. Uses * for all.
         * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [format] Specifies the encoding format of the response. Requests specifying an Accept header:application/json;version&#x3D;2 must not include this field. Valid format field values for this URI are:  1.    tab  2.    csv  3.    xml  4.    wml2 (only if name field is specified)  5.    json (default)  
         * @param {string} [page] This identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLevels(levelIdMask?: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options?: any): AxiosPromise<object> {
            return localVarFp.getCwmsDataLevels(levelIdMask, office, unit, datum, begin, end, timezone, format, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves requested Location Level
         * @summary Get cwmsData levels with levelId
         * @param {string} levelId Specifies the requested location level.
         * @param {string} office Specifies the office of the Location Level to be returned
         * @param {string} effectiveDate Specifies the effective date of Location Level to be returned
         * @param {string} [unit] Desired unit for the values retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLevelsWithLevelId(levelId: string, office: string, effectiveDate: string, unit?: string, options?: any): AxiosPromise<LocationLevel> {
            return localVarFp.getCwmsDataLevelsWithLevelId(levelId, office, effectiveDate, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData specifiedLevels
         * @param {string} [office] Specifies the owning office of the Specified Levels whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [templateIdMask] Mask that specifies the IDs to be included in the response. If this field is not specified, all specified levels shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataSpecifiedLevels(office?: string, templateIdMask?: string, options?: any): AxiosPromise<SpecifiedLevel> {
            return localVarFp.getCwmsDataSpecifiedLevels(office, templateIdMask, options).then((request) => request(axios, basePath));
        },
        /**
         * Update CWMS Location Level
         * @summary Patch cwmsData levels with levelId
         * @param {string} levelId Specifies the location level id of the Location Level to be updated
         * @param {LocationLevel} locationLevel 
         * @param {string} [effectiveDate] Specifies the effective date of Location Level that will be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataLevelsWithLevelId(levelId: string, locationLevel: LocationLevel, effectiveDate?: string, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataLevelsWithLevelId(levelId, locationLevel, effectiveDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames the requested specified level id
         * @summary Patch cwmsData specifiedLevels with specifiedLevelId
         * @param {string} specifiedLevelId 
         * @param {string} specifiedLevelId2 The new specified level id.
         * @param {string} office Specifies the owning office of the specified level to be renamed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId: string, specifiedLevelId2: string, office: string, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId, specifiedLevelId2, office, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new CWMS Location Level
         * @summary Post cwmsData levels
         * @param {LocationLevel} locationLevel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLevels(locationLevel: LocationLevel, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataLevels(locationLevel, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new SpecifiedLevel
         * @summary Post cwmsData specifiedLevels
         * @param {SpecifiedLevel} specifiedLevel 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataSpecifiedLevels(specifiedLevel: SpecifiedLevel, failIfExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataSpecifiedLevels(specifiedLevel, failIfExists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LevelsApi - object-oriented interface
 * @export
 * @class LevelsApi
 * @extends {BaseAPI}
 */
export class LevelsApi extends BaseAPI {
    /**
     * Delete CWMS Location Level
     * @summary Delete cwmsData levels with levelId
     * @param {string} levelId Specifies the location level id of the Location Level to be deleted
     * @param {boolean} [cascadeDelete] 
     * @param {string} [office] Specifies the owning office of the location level whose data is to be deleted. If this field is not specified, matching location level information will be deleted from all offices.
     * @param {string} [effectiveDate] Specifies the effective date of the level to be deleted. If not provided will delete all data and reference to the location level.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public deleteCwmsDataLevelsWithLevelId(levelId: string, cascadeDelete?: boolean, office?: string, effectiveDate?: string, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).deleteCwmsDataLevelsWithLevelId(levelId, cascadeDelete, office, effectiveDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes requested specified level id
     * @summary Delete cwmsData specifiedLevels with specifiedLevelId
     * @param {string} specifiedLevelId The specified level id to be deleted
     * @param {string} office Specifies the owning office of the timeseries identifier to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId: string, office: string, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).deleteCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData levels
     * @param {string} [levelIdMask] Specifies the name(s) of the location level(s) whose data is to be included in the response. Uses * for all.
     * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
     * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
     * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
     * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
     * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
     * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
     * @param {string} [format] Specifies the encoding format of the response. Requests specifying an Accept header:application/json;version&#x3D;2 must not include this field. Valid format field values for this URI are:  1.    tab  2.    csv  3.    xml  4.    wml2 (only if name field is specified)  5.    json (default)  
     * @param {string} [page] This identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getCwmsDataLevels(levelIdMask?: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).getCwmsDataLevels(levelIdMask, office, unit, datum, begin, end, timezone, format, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves requested Location Level
     * @summary Get cwmsData levels with levelId
     * @param {string} levelId Specifies the requested location level.
     * @param {string} office Specifies the office of the Location Level to be returned
     * @param {string} effectiveDate Specifies the effective date of Location Level to be returned
     * @param {string} [unit] Desired unit for the values retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getCwmsDataLevelsWithLevelId(levelId: string, office: string, effectiveDate: string, unit?: string, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).getCwmsDataLevelsWithLevelId(levelId, office, effectiveDate, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData specifiedLevels
     * @param {string} [office] Specifies the owning office of the Specified Levels whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
     * @param {string} [templateIdMask] Mask that specifies the IDs to be included in the response. If this field is not specified, all specified levels shall be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public getCwmsDataSpecifiedLevels(office?: string, templateIdMask?: string, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).getCwmsDataSpecifiedLevels(office, templateIdMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update CWMS Location Level
     * @summary Patch cwmsData levels with levelId
     * @param {string} levelId Specifies the location level id of the Location Level to be updated
     * @param {LocationLevel} locationLevel 
     * @param {string} [effectiveDate] Specifies the effective date of Location Level that will be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public patchCwmsDataLevelsWithLevelId(levelId: string, locationLevel: LocationLevel, effectiveDate?: string, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).patchCwmsDataLevelsWithLevelId(levelId, locationLevel, effectiveDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames the requested specified level id
     * @summary Patch cwmsData specifiedLevels with specifiedLevelId
     * @param {string} specifiedLevelId 
     * @param {string} specifiedLevelId2 The new specified level id.
     * @param {string} office Specifies the owning office of the specified level to be renamed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId: string, specifiedLevelId2: string, office: string, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).patchCwmsDataSpecifiedLevelsWithSpecifiedLevelId(specifiedLevelId, specifiedLevelId2, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new CWMS Location Level
     * @summary Post cwmsData levels
     * @param {LocationLevel} locationLevel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public postCwmsDataLevels(locationLevel: LocationLevel, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).postCwmsDataLevels(locationLevel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new SpecifiedLevel
     * @summary Post cwmsData specifiedLevels
     * @param {SpecifiedLevel} specifiedLevel 
     * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LevelsApi
     */
    public postCwmsDataSpecifiedLevels(specifiedLevel: SpecifiedLevel, failIfExists?: boolean, options?: RawAxiosRequestConfig) {
        return LevelsApiFp(this.configuration).postCwmsDataSpecifiedLevels(specifiedLevel, failIfExists, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationCategoriesApi - axios parameter creator
 * @export
 */
export const LocationCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes requested location category
         * @summary Delete cwmsData location category with categoryId
         * @param {string} categoryId The location category to be deleted
         * @param {string} office Specifies the owning office of the location category to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to delete any location groups in this location category. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLocationCategoryWithCategoryId: async (categoryId: string, office: string, cascadeDelete?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCwmsDataLocationCategoryWithCategoryId', 'categoryId', categoryId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataLocationCategoryWithCategoryId', 'office', office)
            const localVarPath = `/cwms-data/location/category/{category-id}`
                .replace(`{${"category-id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (cascadeDelete !== undefined) {
                localVarQueryParameter['cascade-delete'] = cascadeDelete;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS Location Category Data
         * @summary Get cwmsData location category
         * @param {string} [office] Specifies the owning office of the location category(ies) whose data is to be included in the response. If this field is not specified, matching location category information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationCategory: async (office?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/location/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves requested Location Category
         * @summary Get cwmsData location category with categoryId
         * @param {string} categoryId Specifies the Category whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the Location Category whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationCategoryWithCategoryId: async (categoryId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCwmsDataLocationCategoryWithCategoryId', 'categoryId', categoryId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataLocationCategoryWithCategoryId', 'office', office)
            const localVarPath = `/cwms-data/location/category/{category-id}`
                .replace(`{${"category-id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new LocationCategory
         * @summary Post cwmsData location category
         * @param {LocationCategory} locationCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLocationCategory: async (locationCategory: LocationCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationCategory' is not null or undefined
            assertParamExists('postCwmsDataLocationCategory', 'locationCategory', locationCategory)
            const localVarPath = `/cwms-data/location/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationCategoriesApi - functional programming interface
 * @export
 */
export const LocationCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes requested location category
         * @summary Delete cwmsData location category with categoryId
         * @param {string} categoryId The location category to be deleted
         * @param {string} office Specifies the owning office of the location category to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to delete any location groups in this location category. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataLocationCategoryWithCategoryId(categoryId: string, office: string, cascadeDelete?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataLocationCategoryWithCategoryId(categoryId, office, cascadeDelete, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationCategoriesApi.deleteCwmsDataLocationCategoryWithCategoryId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS Location Category Data
         * @summary Get cwmsData location category
         * @param {string} [office] Specifies the owning office of the location category(ies) whose data is to be included in the response. If this field is not specified, matching location category information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLocationCategory(office?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocationCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLocationCategory(office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationCategoriesApi.getCwmsDataLocationCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves requested Location Category
         * @summary Get cwmsData location category with categoryId
         * @param {string} categoryId Specifies the Category whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the Location Category whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLocationCategoryWithCategoryId(categoryId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLocationCategoryWithCategoryId(categoryId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationCategoriesApi.getCwmsDataLocationCategoryWithCategoryId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new LocationCategory
         * @summary Post cwmsData location category
         * @param {LocationCategory} locationCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataLocationCategory(locationCategory: LocationCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataLocationCategory(locationCategory, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationCategoriesApi.postCwmsDataLocationCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LocationCategoriesApi - factory interface
 * @export
 */
export const LocationCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationCategoriesApiFp(configuration)
    return {
        /**
         * Deletes requested location category
         * @summary Delete cwmsData location category with categoryId
         * @param {string} categoryId The location category to be deleted
         * @param {string} office Specifies the owning office of the location category to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to delete any location groups in this location category. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLocationCategoryWithCategoryId(categoryId: string, office: string, cascadeDelete?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataLocationCategoryWithCategoryId(categoryId, office, cascadeDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS Location Category Data
         * @summary Get cwmsData location category
         * @param {string} [office] Specifies the owning office of the location category(ies) whose data is to be included in the response. If this field is not specified, matching location category information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationCategory(office?: string, options?: any): AxiosPromise<Array<LocationCategory>> {
            return localVarFp.getCwmsDataLocationCategory(office, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves requested Location Category
         * @summary Get cwmsData location category with categoryId
         * @param {string} categoryId Specifies the Category whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the Location Category whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationCategoryWithCategoryId(categoryId: string, office: string, options?: any): AxiosPromise<LocationCategory> {
            return localVarFp.getCwmsDataLocationCategoryWithCategoryId(categoryId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new LocationCategory
         * @summary Post cwmsData location category
         * @param {LocationCategory} locationCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLocationCategory(locationCategory: LocationCategory, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataLocationCategory(locationCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationCategoriesApi - object-oriented interface
 * @export
 * @class LocationCategoriesApi
 * @extends {BaseAPI}
 */
export class LocationCategoriesApi extends BaseAPI {
    /**
     * Deletes requested location category
     * @summary Delete cwmsData location category with categoryId
     * @param {string} categoryId The location category to be deleted
     * @param {string} office Specifies the owning office of the location category to be deleted
     * @param {boolean} [cascadeDelete] Specifies whether to delete any location groups in this location category. Default: false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCategoriesApi
     */
    public deleteCwmsDataLocationCategoryWithCategoryId(categoryId: string, office: string, cascadeDelete?: boolean, options?: RawAxiosRequestConfig) {
        return LocationCategoriesApiFp(this.configuration).deleteCwmsDataLocationCategoryWithCategoryId(categoryId, office, cascadeDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS Location Category Data
     * @summary Get cwmsData location category
     * @param {string} [office] Specifies the owning office of the location category(ies) whose data is to be included in the response. If this field is not specified, matching location category information from all offices shall be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCategoriesApi
     */
    public getCwmsDataLocationCategory(office?: string, options?: RawAxiosRequestConfig) {
        return LocationCategoriesApiFp(this.configuration).getCwmsDataLocationCategory(office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves requested Location Category
     * @summary Get cwmsData location category with categoryId
     * @param {string} categoryId Specifies the Category whose data is to be included in the response.
     * @param {string} office Specifies the owning office of the Location Category whose data is to be included in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCategoriesApi
     */
    public getCwmsDataLocationCategoryWithCategoryId(categoryId: string, office: string, options?: RawAxiosRequestConfig) {
        return LocationCategoriesApiFp(this.configuration).getCwmsDataLocationCategoryWithCategoryId(categoryId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new LocationCategory
     * @summary Post cwmsData location category
     * @param {LocationCategory} locationCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCategoriesApi
     */
    public postCwmsDataLocationCategory(locationCategory: LocationCategory, options?: RawAxiosRequestConfig) {
        return LocationCategoriesApiFp(this.configuration).postCwmsDataLocationCategory(locationCategory, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationGroupsApi - axios parameter creator
 * @export
 */
export const LocationGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes requested location group
         * @summary Delete cwmsData location group with groupId
         * @param {string} groupId The location group to be deleted
         * @param {string} categoryId Specifies the location category of the location group to be deleted
         * @param {string} office Specifies the owning office of the location group to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to specifies whether to unassign any location assignments. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLocationGroupWithGroupId: async (groupId: string, categoryId: string, office: string, cascadeDelete?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteCwmsDataLocationGroupWithGroupId', 'groupId', groupId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCwmsDataLocationGroupWithGroupId', 'categoryId', categoryId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataLocationGroupWithGroupId', 'office', office)
            const localVarPath = `/cwms-data/location/group/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (categoryId !== undefined) {
                localVarQueryParameter['category-id'] = categoryId;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (cascadeDelete !== undefined) {
                localVarQueryParameter['cascade-delete'] = cascadeDelete;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS Location Groups Data
         * @summary Get cwmsData location group
         * @param {string} [office] Specifies the owning office of the location group(s) whose data is to be included in the response. If this field is not specified, matching location groups information from all offices shall be returned.
         * @param {boolean} [includeAssigned] Include the assigned locations in the returned location groups. (default: false)
         * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationGroup: async (office?: string, includeAssigned?: boolean, locationCategoryLike?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/location/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (includeAssigned !== undefined) {
                localVarQueryParameter['include-assigned'] = includeAssigned;
            }

            if (locationCategoryLike !== undefined) {
                localVarQueryParameter['location-category-like'] = locationCategoryLike;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves requested Location Group
         * @summary Get cwmsData location group with groupId
         * @param {string} groupId Specifies the location_group whose data is to be included in the response
         * @param {string} office Specifies the owning office of the location group whose data is to be included in the response.
         * @param {string} categoryId Specifies the category containing the location group whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationGroupWithGroupId: async (groupId: string, office: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getCwmsDataLocationGroupWithGroupId', 'groupId', groupId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataLocationGroupWithGroupId', 'office', office)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCwmsDataLocationGroupWithGroupId', 'categoryId', categoryId)
            const localVarPath = `/cwms-data/location/group/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category-id'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing LocationGroup
         * @summary Patch cwmsData location group with groupId
         * @param {string} groupId 
         * @param {string} office Specifies the owning office of the location group to be updated
         * @param {LocationGroup} locationGroup 
         * @param {boolean} [replaceAssignedLocs] Specifies whether to unassign all existing locations before assigning new locations specified in the content body Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataLocationGroupWithGroupId: async (groupId: string, office: string, locationGroup: LocationGroup, replaceAssignedLocs?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('patchCwmsDataLocationGroupWithGroupId', 'groupId', groupId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('patchCwmsDataLocationGroupWithGroupId', 'office', office)
            // verify required parameter 'locationGroup' is not null or undefined
            assertParamExists('patchCwmsDataLocationGroupWithGroupId', 'locationGroup', locationGroup)
            const localVarPath = `/cwms-data/location/group/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (replaceAssignedLocs !== undefined) {
                localVarQueryParameter['replace-assigned-locs'] = replaceAssignedLocs;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new LocationGroup
         * @summary Post cwmsData location group
         * @param {LocationGroup} locationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLocationGroup: async (locationGroup: LocationGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationGroup' is not null or undefined
            assertParamExists('postCwmsDataLocationGroup', 'locationGroup', locationGroup)
            const localVarPath = `/cwms-data/location/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationGroupsApi - functional programming interface
 * @export
 */
export const LocationGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes requested location group
         * @summary Delete cwmsData location group with groupId
         * @param {string} groupId The location group to be deleted
         * @param {string} categoryId Specifies the location category of the location group to be deleted
         * @param {string} office Specifies the owning office of the location group to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to specifies whether to unassign any location assignments. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataLocationGroupWithGroupId(groupId: string, categoryId: string, office: string, cascadeDelete?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataLocationGroupWithGroupId(groupId, categoryId, office, cascadeDelete, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationGroupsApi.deleteCwmsDataLocationGroupWithGroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS Location Groups Data
         * @summary Get cwmsData location group
         * @param {string} [office] Specifies the owning office of the location group(s) whose data is to be included in the response. If this field is not specified, matching location groups information from all offices shall be returned.
         * @param {boolean} [includeAssigned] Include the assigned locations in the returned location groups. (default: false)
         * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLocationGroup(office?: string, includeAssigned?: boolean, locationCategoryLike?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocationGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLocationGroup(office, includeAssigned, locationCategoryLike, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationGroupsApi.getCwmsDataLocationGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves requested Location Group
         * @summary Get cwmsData location group with groupId
         * @param {string} groupId Specifies the location_group whose data is to be included in the response
         * @param {string} office Specifies the owning office of the location group whose data is to be included in the response.
         * @param {string} categoryId Specifies the category containing the location group whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLocationGroupWithGroupId(groupId: string, office: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLocationGroupWithGroupId(groupId, office, categoryId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationGroupsApi.getCwmsDataLocationGroupWithGroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update existing LocationGroup
         * @summary Patch cwmsData location group with groupId
         * @param {string} groupId 
         * @param {string} office Specifies the owning office of the location group to be updated
         * @param {LocationGroup} locationGroup 
         * @param {boolean} [replaceAssignedLocs] Specifies whether to unassign all existing locations before assigning new locations specified in the content body Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataLocationGroupWithGroupId(groupId: string, office: string, locationGroup: LocationGroup, replaceAssignedLocs?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataLocationGroupWithGroupId(groupId, office, locationGroup, replaceAssignedLocs, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationGroupsApi.patchCwmsDataLocationGroupWithGroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new LocationGroup
         * @summary Post cwmsData location group
         * @param {LocationGroup} locationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataLocationGroup(locationGroup: LocationGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataLocationGroup(locationGroup, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationGroupsApi.postCwmsDataLocationGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LocationGroupsApi - factory interface
 * @export
 */
export const LocationGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationGroupsApiFp(configuration)
    return {
        /**
         * Deletes requested location group
         * @summary Delete cwmsData location group with groupId
         * @param {string} groupId The location group to be deleted
         * @param {string} categoryId Specifies the location category of the location group to be deleted
         * @param {string} office Specifies the owning office of the location group to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to specifies whether to unassign any location assignments. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLocationGroupWithGroupId(groupId: string, categoryId: string, office: string, cascadeDelete?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataLocationGroupWithGroupId(groupId, categoryId, office, cascadeDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS Location Groups Data
         * @summary Get cwmsData location group
         * @param {string} [office] Specifies the owning office of the location group(s) whose data is to be included in the response. If this field is not specified, matching location groups information from all offices shall be returned.
         * @param {boolean} [includeAssigned] Include the assigned locations in the returned location groups. (default: false)
         * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationGroup(office?: string, includeAssigned?: boolean, locationCategoryLike?: string, options?: any): AxiosPromise<Array<LocationGroup>> {
            return localVarFp.getCwmsDataLocationGroup(office, includeAssigned, locationCategoryLike, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves requested Location Group
         * @summary Get cwmsData location group with groupId
         * @param {string} groupId Specifies the location_group whose data is to be included in the response
         * @param {string} office Specifies the owning office of the location group whose data is to be included in the response.
         * @param {string} categoryId Specifies the category containing the location group whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationGroupWithGroupId(groupId: string, office: string, categoryId: string, options?: any): AxiosPromise<LocationGroup> {
            return localVarFp.getCwmsDataLocationGroupWithGroupId(groupId, office, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing LocationGroup
         * @summary Patch cwmsData location group with groupId
         * @param {string} groupId 
         * @param {string} office Specifies the owning office of the location group to be updated
         * @param {LocationGroup} locationGroup 
         * @param {boolean} [replaceAssignedLocs] Specifies whether to unassign all existing locations before assigning new locations specified in the content body Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataLocationGroupWithGroupId(groupId: string, office: string, locationGroup: LocationGroup, replaceAssignedLocs?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataLocationGroupWithGroupId(groupId, office, locationGroup, replaceAssignedLocs, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new LocationGroup
         * @summary Post cwmsData location group
         * @param {LocationGroup} locationGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLocationGroup(locationGroup: LocationGroup, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataLocationGroup(locationGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationGroupsApi - object-oriented interface
 * @export
 * @class LocationGroupsApi
 * @extends {BaseAPI}
 */
export class LocationGroupsApi extends BaseAPI {
    /**
     * Deletes requested location group
     * @summary Delete cwmsData location group with groupId
     * @param {string} groupId The location group to be deleted
     * @param {string} categoryId Specifies the location category of the location group to be deleted
     * @param {string} office Specifies the owning office of the location group to be deleted
     * @param {boolean} [cascadeDelete] Specifies whether to specifies whether to unassign any location assignments. Default: false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationGroupsApi
     */
    public deleteCwmsDataLocationGroupWithGroupId(groupId: string, categoryId: string, office: string, cascadeDelete?: boolean, options?: RawAxiosRequestConfig) {
        return LocationGroupsApiFp(this.configuration).deleteCwmsDataLocationGroupWithGroupId(groupId, categoryId, office, cascadeDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS Location Groups Data
     * @summary Get cwmsData location group
     * @param {string} [office] Specifies the owning office of the location group(s) whose data is to be included in the response. If this field is not specified, matching location groups information from all offices shall be returned.
     * @param {boolean} [includeAssigned] Include the assigned locations in the returned location groups. (default: false)
     * @param {string} [locationCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the location category id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationGroupsApi
     */
    public getCwmsDataLocationGroup(office?: string, includeAssigned?: boolean, locationCategoryLike?: string, options?: RawAxiosRequestConfig) {
        return LocationGroupsApiFp(this.configuration).getCwmsDataLocationGroup(office, includeAssigned, locationCategoryLike, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves requested Location Group
     * @summary Get cwmsData location group with groupId
     * @param {string} groupId Specifies the location_group whose data is to be included in the response
     * @param {string} office Specifies the owning office of the location group whose data is to be included in the response.
     * @param {string} categoryId Specifies the category containing the location group whose data is to be included in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationGroupsApi
     */
    public getCwmsDataLocationGroupWithGroupId(groupId: string, office: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return LocationGroupsApiFp(this.configuration).getCwmsDataLocationGroupWithGroupId(groupId, office, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing LocationGroup
     * @summary Patch cwmsData location group with groupId
     * @param {string} groupId 
     * @param {string} office Specifies the owning office of the location group to be updated
     * @param {LocationGroup} locationGroup 
     * @param {boolean} [replaceAssignedLocs] Specifies whether to unassign all existing locations before assigning new locations specified in the content body Default: false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationGroupsApi
     */
    public patchCwmsDataLocationGroupWithGroupId(groupId: string, office: string, locationGroup: LocationGroup, replaceAssignedLocs?: boolean, options?: RawAxiosRequestConfig) {
        return LocationGroupsApiFp(this.configuration).patchCwmsDataLocationGroupWithGroupId(groupId, office, locationGroup, replaceAssignedLocs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new LocationGroup
     * @summary Post cwmsData location group
     * @param {LocationGroup} locationGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationGroupsApi
     */
    public postCwmsDataLocationGroup(locationGroup: LocationGroup, options?: RawAxiosRequestConfig) {
        return LocationGroupsApiFp(this.configuration).postCwmsDataLocationGroup(locationGroup, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete CWMS Location
         * @summary Delete cwmsData locations with locationId
         * @param {string} locationId 
         * @param {string} [office] Specifies the owning office of the location whose data is to be deleted. If this field is not specified, matching location information will be deleted from all offices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLocationsWithLocationId: async (locationId: string, office?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('deleteCwmsDataLocationsWithLocationId', 'locationId', locationId)
            const localVarPath = `/cwms-data/locations/{location-id}`
                .replace(`{${"location-id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS Location Data
         * @summary Get cwmsData locations
         * @param {string} [names] Specifies the name(s) of the location(s) whose data is to be included in the response
         * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default) 6.    geojson
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocations: async (names?: string, office?: string, unit?: string, datum?: string, format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (datum !== undefined) {
                localVarQueryParameter['datum'] = datum;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS Location Data
         * @summary Get cwmsData locations with locationId
         * @param {string} locationId 
         * @param {string} office Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationsWithLocationId: async (locationId: string, office: string, unit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('getCwmsDataLocationsWithLocationId', 'locationId', locationId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataLocationsWithLocationId', 'office', office)
            const localVarPath = `/cwms-data/locations/{location-id}`
                .replace(`{${"location-id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CWMS Location
         * @summary Patch cwmsData locations with locationId
         * @param {string} locationId 
         * @param {Location} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataLocationsWithLocationId: async (locationId: string, location: Location, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('patchCwmsDataLocationsWithLocationId', 'locationId', locationId)
            // verify required parameter 'location' is not null or undefined
            assertParamExists('patchCwmsDataLocationsWithLocationId', 'location', location)
            const localVarPath = `/cwms-data/locations/{location-id}`
                .replace(`{${"location-id"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(location, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new CWMS Location
         * @summary Post cwmsData locations
         * @param {Location} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLocations: async (location: Location, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('postCwmsDataLocations', 'location', location)
            const localVarPath = `/cwms-data/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(location, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete CWMS Location
         * @summary Delete cwmsData locations with locationId
         * @param {string} locationId 
         * @param {string} [office] Specifies the owning office of the location whose data is to be deleted. If this field is not specified, matching location information will be deleted from all offices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataLocationsWithLocationId(locationId: string, office?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataLocationsWithLocationId(locationId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationsApi.deleteCwmsDataLocationsWithLocationId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS Location Data
         * @summary Get cwmsData locations
         * @param {string} [names] Specifies the name(s) of the location(s) whose data is to be included in the response
         * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default) 6.    geojson
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLocations(names?: string, office?: string, unit?: string, datum?: string, format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLocations(names, office, unit, datum, format, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationsApi.getCwmsDataLocations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS Location Data
         * @summary Get cwmsData locations with locationId
         * @param {string} locationId 
         * @param {string} office Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataLocationsWithLocationId(locationId: string, office: string, unit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataLocationsWithLocationId(locationId, office, unit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationsApi.getCwmsDataLocationsWithLocationId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update CWMS Location
         * @summary Patch cwmsData locations with locationId
         * @param {string} locationId 
         * @param {Location} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataLocationsWithLocationId(locationId: string, location: Location, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataLocationsWithLocationId(locationId, location, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationsApi.patchCwmsDataLocationsWithLocationId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new CWMS Location
         * @summary Post cwmsData locations
         * @param {Location} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataLocations(location: Location, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataLocations(location, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocationsApi.postCwmsDataLocations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationsApiFp(configuration)
    return {
        /**
         * Delete CWMS Location
         * @summary Delete cwmsData locations with locationId
         * @param {string} locationId 
         * @param {string} [office] Specifies the owning office of the location whose data is to be deleted. If this field is not specified, matching location information will be deleted from all offices.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataLocationsWithLocationId(locationId: string, office?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataLocationsWithLocationId(locationId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS Location Data
         * @summary Get cwmsData locations
         * @param {string} [names] Specifies the name(s) of the location(s) whose data is to be included in the response
         * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default) 6.    geojson
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocations(names?: string, office?: string, unit?: string, datum?: string, format?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getCwmsDataLocations(names, office, unit, datum, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS Location Data
         * @summary Get cwmsData locations with locationId
         * @param {string} locationId 
         * @param {string} office Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataLocationsWithLocationId(locationId: string, office: string, unit?: string, options?: any): AxiosPromise<Location> {
            return localVarFp.getCwmsDataLocationsWithLocationId(locationId, office, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update CWMS Location
         * @summary Patch cwmsData locations with locationId
         * @param {string} locationId 
         * @param {Location} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataLocationsWithLocationId(locationId: string, location: Location, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataLocationsWithLocationId(locationId, location, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new CWMS Location
         * @summary Post cwmsData locations
         * @param {Location} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataLocations(location: Location, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataLocations(location, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
    /**
     * Delete CWMS Location
     * @summary Delete cwmsData locations with locationId
     * @param {string} locationId 
     * @param {string} [office] Specifies the owning office of the location whose data is to be deleted. If this field is not specified, matching location information will be deleted from all offices.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public deleteCwmsDataLocationsWithLocationId(locationId: string, office?: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).deleteCwmsDataLocationsWithLocationId(locationId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS Location Data
     * @summary Get cwmsData locations
     * @param {string} [names] Specifies the name(s) of the location(s) whose data is to be included in the response
     * @param {string} [office] Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
     * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
     * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
     * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default) 6.    geojson
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public getCwmsDataLocations(names?: string, office?: string, unit?: string, datum?: string, format?: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).getCwmsDataLocations(names, office, unit, datum, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS Location Data
     * @summary Get cwmsData locations with locationId
     * @param {string} locationId 
     * @param {string} office Specifies the owning office of the location level(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
     * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   Specifies English unit system.  Location values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public getCwmsDataLocationsWithLocationId(locationId: string, office: string, unit?: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).getCwmsDataLocationsWithLocationId(locationId, office, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update CWMS Location
     * @summary Patch cwmsData locations with locationId
     * @param {string} locationId 
     * @param {Location} location 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public patchCwmsDataLocationsWithLocationId(locationId: string, location: Location, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).patchCwmsDataLocationsWithLocationId(locationId, location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new CWMS Location
     * @summary Post cwmsData locations
     * @param {Location} location 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public postCwmsDataLocations(location: Location, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).postCwmsDataLocations(location, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OfficesApi - axios parameter creator
 * @export
 */
export const OfficesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData offices
         * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {boolean} [hasData] A flag (\&#39;True\&#39;/\&#39;False\&#39;) When set to true this returns offices that have operational data. Default value is &lt;b&gt;False&lt;/b&gt;,. &lt;a href&#x3D;\&quot;https://github.com/USACE/cwms-data-api/issues/321\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Feature #321&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataOffices: async (format?: string, hasData?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/offices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (hasData !== undefined) {
                localVarQueryParameter['has-data'] = hasData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData offices with office
         * @param {string} office The 3 letter office ID you want more information for
         * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataOfficesWithOffice: async (office: string, format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataOfficesWithOffice', 'office', office)
            const localVarPath = `/cwms-data/offices/{office}`
                .replace(`{${"office"}}`, encodeURIComponent(String(office)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OfficesApi - functional programming interface
 * @export
 */
export const OfficesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OfficesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData offices
         * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {boolean} [hasData] A flag (\&#39;True\&#39;/\&#39;False\&#39;) When set to true this returns offices that have operational data. Default value is &lt;b&gt;False&lt;/b&gt;,. &lt;a href&#x3D;\&quot;https://github.com/USACE/cwms-data-api/issues/321\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Feature #321&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataOffices(format?: string, hasData?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfficeFormatV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataOffices(format, hasData, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OfficesApi.getCwmsDataOffices']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData offices with office
         * @param {string} office The 3 letter office ID you want more information for
         * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataOfficesWithOffice(office: string, format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfficeFormatV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataOfficesWithOffice(office, format, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OfficesApi.getCwmsDataOfficesWithOffice']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OfficesApi - factory interface
 * @export
 */
export const OfficesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OfficesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData offices
         * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {boolean} [hasData] A flag (\&#39;True\&#39;/\&#39;False\&#39;) When set to true this returns offices that have operational data. Default value is &lt;b&gt;False&lt;/b&gt;,. &lt;a href&#x3D;\&quot;https://github.com/USACE/cwms-data-api/issues/321\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Feature #321&lt;/a&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataOffices(format?: string, hasData?: boolean, options?: any): AxiosPromise<OfficeFormatV1> {
            return localVarFp.getCwmsDataOffices(format, hasData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData offices with office
         * @param {string} office The 3 letter office ID you want more information for
         * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataOfficesWithOffice(office: string, format?: string, options?: any): AxiosPromise<OfficeFormatV1> {
            return localVarFp.getCwmsDataOfficesWithOffice(office, format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OfficesApi - object-oriented interface
 * @export
 * @class OfficesApi
 * @extends {BaseAPI}
 */
export class OfficesApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData offices
     * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
     * @param {boolean} [hasData] A flag (\&#39;True\&#39;/\&#39;False\&#39;) When set to true this returns offices that have operational data. Default value is &lt;b&gt;False&lt;/b&gt;,. &lt;a href&#x3D;\&quot;https://github.com/USACE/cwms-data-api/issues/321\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Feature #321&lt;/a&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficesApi
     */
    public getCwmsDataOffices(format?: string, hasData?: boolean, options?: RawAxiosRequestConfig) {
        return OfficesApiFp(this.configuration).getCwmsDataOffices(format, hasData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData offices with office
     * @param {string} office The 3 letter office ID you want more information for
     * @param {string} [format] (Deprecated in favor of Accept header) Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficesApi
     */
    public getCwmsDataOfficesWithOffice(office: string, format?: string, options?: RawAxiosRequestConfig) {
        return OfficesApiFp(this.configuration).getCwmsDataOfficesWithOffice(office, format, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ParametersApi - axios parameter creator
 * @export
 */
export const ParametersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData parameters
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataParameters: async (format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParametersApi - functional programming interface
 * @export
 */
export const ParametersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParametersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData parameters
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataParameters(format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataParameters(format, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ParametersApi.getCwmsDataParameters']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ParametersApi - factory interface
 * @export
 */
export const ParametersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParametersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData parameters
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataParameters(format?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCwmsDataParameters(format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParametersApi - object-oriented interface
 * @export
 * @class ParametersApi
 * @extends {BaseAPI}
 */
export class ParametersApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData parameters
     * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParametersApi
     */
    public getCwmsDataParameters(format?: string, options?: RawAxiosRequestConfig) {
        return ParametersApiFp(this.configuration).getCwmsDataParameters(format, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns Pools Data
         * @summary Get cwmsData pools
         * @param {string} [office] Specifies the owning office of the data in the response. If this field is not specified, matching items from all offices shall be returned.
         * @param {string} [idMask] Project Id mask. Default value:*
         * @param {string} [nameMask] Name mask. Default value:*
         * @param {string} [bottomMask] Bottom level mask. Default value:*
         * @param {string} [topMask] Top level mask. Default value:*
         * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
         * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataPools: async (office?: string, idMask?: string, nameMask?: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, page?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (idMask !== undefined) {
                localVarQueryParameter['id-mask'] = idMask;
            }

            if (nameMask !== undefined) {
                localVarQueryParameter['name-mask'] = nameMask;
            }

            if (bottomMask !== undefined) {
                localVarQueryParameter['bottom-mask'] = bottomMask;
            }

            if (topMask !== undefined) {
                localVarQueryParameter['top-mask'] = topMask;
            }

            if (includeExplicit !== undefined) {
                localVarQueryParameter['include-explicit'] = includeExplicit;
            }

            if (includeImplicit !== undefined) {
                localVarQueryParameter['include-implicit'] = includeImplicit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves requested Pool
         * @summary Get cwmsData pools with poolId
         * @param {string} poolId Specifies the pool whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the Pool whose data is to be included in the response.
         * @param {string} projectId Specifies the project-id of the Pool whose data is to be included in the response.
         * @param {string} [bottomMask] Bottom level mask. Default value:*
         * @param {string} [topMask] Top level mask. Default value:*
         * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
         * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataPoolsWithPoolId: async (poolId: string, office: string, projectId: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('getCwmsDataPoolsWithPoolId', 'poolId', poolId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataPoolsWithPoolId', 'office', office)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCwmsDataPoolsWithPoolId', 'projectId', projectId)
            const localVarPath = `/cwms-data/pools/{pool-id}`
                .replace(`{${"pool-id"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project-id'] = projectId;
            }

            if (bottomMask !== undefined) {
                localVarQueryParameter['bottom-mask'] = bottomMask;
            }

            if (topMask !== undefined) {
                localVarQueryParameter['top-mask'] = topMask;
            }

            if (includeExplicit !== undefined) {
                localVarQueryParameter['include-explicit'] = includeExplicit;
            }

            if (includeImplicit !== undefined) {
                localVarQueryParameter['include-implicit'] = includeImplicit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns Pools Data
         * @summary Get cwmsData pools
         * @param {string} [office] Specifies the owning office of the data in the response. If this field is not specified, matching items from all offices shall be returned.
         * @param {string} [idMask] Project Id mask. Default value:*
         * @param {string} [nameMask] Name mask. Default value:*
         * @param {string} [bottomMask] Bottom level mask. Default value:*
         * @param {string} [topMask] Top level mask. Default value:*
         * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
         * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataPools(office?: string, idMask?: string, nameMask?: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataPools(office, idMask, nameMask, bottomMask, topMask, includeExplicit, includeImplicit, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoolsApi.getCwmsDataPools']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves requested Pool
         * @summary Get cwmsData pools with poolId
         * @param {string} poolId Specifies the pool whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the Pool whose data is to be included in the response.
         * @param {string} projectId Specifies the project-id of the Pool whose data is to be included in the response.
         * @param {string} [bottomMask] Bottom level mask. Default value:*
         * @param {string} [topMask] Top level mask. Default value:*
         * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
         * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataPoolsWithPoolId(poolId: string, office: string, projectId: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataPoolsWithPoolId(poolId, office, projectId, bottomMask, topMask, includeExplicit, includeImplicit, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoolsApi.getCwmsDataPoolsWithPoolId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * Returns Pools Data
         * @summary Get cwmsData pools
         * @param {string} [office] Specifies the owning office of the data in the response. If this field is not specified, matching items from all offices shall be returned.
         * @param {string} [idMask] Project Id mask. Default value:*
         * @param {string} [nameMask] Name mask. Default value:*
         * @param {string} [bottomMask] Bottom level mask. Default value:*
         * @param {string} [topMask] Top level mask. Default value:*
         * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
         * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataPools(office?: string, idMask?: string, nameMask?: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, page?: string, pageSize?: number, options?: any): AxiosPromise<Pools> {
            return localVarFp.getCwmsDataPools(office, idMask, nameMask, bottomMask, topMask, includeExplicit, includeImplicit, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves requested Pool
         * @summary Get cwmsData pools with poolId
         * @param {string} poolId Specifies the pool whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the Pool whose data is to be included in the response.
         * @param {string} projectId Specifies the project-id of the Pool whose data is to be included in the response.
         * @param {string} [bottomMask] Bottom level mask. Default value:*
         * @param {string} [topMask] Top level mask. Default value:*
         * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
         * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataPoolsWithPoolId(poolId: string, office: string, projectId: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, options?: any): AxiosPromise<Pool> {
            return localVarFp.getCwmsDataPoolsWithPoolId(poolId, office, projectId, bottomMask, topMask, includeExplicit, includeImplicit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * Returns Pools Data
     * @summary Get cwmsData pools
     * @param {string} [office] Specifies the owning office of the data in the response. If this field is not specified, matching items from all offices shall be returned.
     * @param {string} [idMask] Project Id mask. Default value:*
     * @param {string} [nameMask] Name mask. Default value:*
     * @param {string} [bottomMask] Bottom level mask. Default value:*
     * @param {string} [topMask] Top level mask. Default value:*
     * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
     * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getCwmsDataPools(office?: string, idMask?: string, nameMask?: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).getCwmsDataPools(office, idMask, nameMask, bottomMask, topMask, includeExplicit, includeImplicit, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves requested Pool
     * @summary Get cwmsData pools with poolId
     * @param {string} poolId Specifies the pool whose data is to be included in the response.
     * @param {string} office Specifies the owning office of the Pool whose data is to be included in the response.
     * @param {string} projectId Specifies the project-id of the Pool whose data is to be included in the response.
     * @param {string} [bottomMask] Bottom level mask. Default value:*
     * @param {string} [topMask] Top level mask. Default value:*
     * @param {string} [includeExplicit] Specifies if the results should include explicit Pools. Default value:false
     * @param {string} [includeImplicit] Specifies if the results should include implicit Pools. Default value:true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getCwmsDataPoolsWithPoolId(poolId: string, office: string, projectId: string, bottomMask?: string, topMask?: string, includeExplicit?: string, includeImplicit?: string, options?: RawAxiosRequestConfig) {
        return PoolsApiFp(this.configuration).getCwmsDataPoolsWithPoolId(poolId, office, projectId, bottomMask, topMask, includeExplicit, includeImplicit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RatingsApi - axios parameter creator
 * @export
 */
export const RatingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes requested rating specification
         * @summary Delete cwmsData ratings spec with ratingId
         * @param {string} ratingId The rating-spec-id of the ratings data to be deleted.
         * @param {string} office Specifies the owning office of the ratings to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataRatingsSpecWithRatingId: async (ratingId: string, office: string, method: DeleteMethod, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsSpecWithRatingId', 'ratingId', ratingId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsSpecWithRatingId', 'office', office)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsSpecWithRatingId', 'method', method)
            const localVarPath = `/cwms-data/ratings/spec/{rating-id}`
                .replace(`{${"rating-id"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes requested rating specification
         * @summary Delete cwmsData ratings template with templateId
         * @param {string} templateId The rating-template-id of the ratings data to be deleted.
         * @param {string} office Specifies the owning office of the ratings to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataRatingsTemplateWithTemplateId: async (templateId: string, office: string, method: DeleteMethod, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsTemplateWithTemplateId', 'templateId', templateId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsTemplateWithTemplateId', 'office', office)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsTemplateWithTemplateId', 'method', method)
            const localVarPath = `/cwms-data/ratings/template/{template-id}`
                .replace(`{${"template-id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete cwmsData ratings with ratingId
         * @param {string} ratingId The rating-id of the effective dates to be deleted. 
         * @param {string} office Specifies the office of the ratings to be deleted.
         * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataRatingsWithRatingId: async (ratingId: string, office: string, begin: string, end: string, timezone?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsWithRatingId', 'ratingId', ratingId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsWithRatingId', 'office', office)
            // verify required parameter 'begin' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsWithRatingId', 'begin', begin)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('deleteCwmsDataRatingsWithRatingId', 'end', end)
            const localVarPath = `/cwms-data/ratings/{rating-id}`
                .replace(`{${"rating-id"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData ratings
         * @param {string} [name] Specifies the name(s) of the rating whose data is to be included in the response. A case insensitive comparison is used to match names.
         * @param {string} [office] Specifies the owning office of the Rating(s) whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:  1. EN.   Specifies English unit system.  Rating values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Rating values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation Ratings. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [at] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.    json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatings: async (name?: string, office?: string, unit?: string, datum?: string, at?: string, end?: string, timezone?: string, format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (datum !== undefined) {
                localVarQueryParameter['datum'] = datum;
            }

            if (at !== undefined) {
                localVarQueryParameter['at'] = at;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData ratings metadata
         * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [ratingIdMask] RegExp that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
         * @param {string} [start] Specifies the start of the time window of the effective dates to be included. If this field is not specified no start time will be used.
         * @param {string} [end] Specifies the end of the time window for effective dates to be included. If this field is not specified no end time will be used.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsMetadata: async (office?: string, ratingIdMask?: string, start?: string, end?: string, timezone?: string, page?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/ratings/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (ratingIdMask !== undefined) {
                localVarQueryParameter['rating-id-mask'] = ratingIdMask;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData ratings spec
         * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [ratingIdMask] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt;  that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsSpec: async (office?: string, ratingIdMask?: string, page?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/ratings/spec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (ratingIdMask !== undefined) {
                localVarQueryParameter['rating-id-mask'] = ratingIdMask;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData ratings spec with ratingId
         * @param {string} ratingId Specifies the rating-id of the Rating Spec to be included in the response
         * @param {string} office Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsSpecWithRatingId: async (ratingId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('getCwmsDataRatingsSpecWithRatingId', 'ratingId', ratingId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataRatingsSpecWithRatingId', 'office', office)
            const localVarPath = `/cwms-data/ratings/spec/{rating-id}`
                .replace(`{${"rating-id"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData ratings template
         * @param {string} [office] Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [templateIdMask] RegExp that specifies the rating template IDs to be included in the response. If this field is not specified, all rating templates shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsTemplate: async (office?: string, templateIdMask?: string, page?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/ratings/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (templateIdMask !== undefined) {
                localVarQueryParameter['template-id-mask'] = templateIdMask;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData ratings template with templateId
         * @param {string} templateId Specifies the template whose data is to be included in the response
         * @param {string} office Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsTemplateWithTemplateId: async (templateId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getCwmsDataRatingsTemplateWithTemplateId', 'templateId', templateId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataRatingsTemplateWithTemplateId', 'office', office)
            const localVarPath = `/cwms-data/ratings/template/{template-id}`
                .replace(`{${"template-id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS Rating Data
         * @summary Get cwmsData ratings with ratingId
         * @param {string} ratingId The rating-id of the effective dates to be retrieve. 
         * @param {string} office Specifies the owning office of the ratingset to be included in the response.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified no start time will be used.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified no end time will be used.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {DatabaseLoadMethod} [method] Specifies the retrieval method used.  If no method is provided EAGER will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsWithRatingId: async (ratingId: string, office: string, begin?: string, end?: string, timezone?: string, method?: DatabaseLoadMethod, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('getCwmsDataRatingsWithRatingId', 'ratingId', ratingId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataRatingsWithRatingId', 'office', office)
            const localVarPath = `/cwms-data/ratings/{rating-id}`
                .replace(`{${"rating-id"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a RatingSet
         * @summary Patch cwmsData ratings with ratingId
         * @param {string} ratingId 
         * @param {object} body 
         * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataRatingsWithRatingId: async (ratingId: string, body: object, storeTemplate?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('patchCwmsDataRatingsWithRatingId', 'ratingId', ratingId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchCwmsDataRatingsWithRatingId', 'body', body)
            const localVarPath = `/cwms-data/ratings/{rating-id}`
                .replace(`{${"rating-id"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (storeTemplate !== undefined) {
                localVarQueryParameter['store-template'] = storeTemplate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new RatingSet
         * @summary Post cwmsData ratings
         * @param {object} body 
         * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataRatings: async (body: object, storeTemplate?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postCwmsDataRatings', 'body', body)
            const localVarPath = `/cwms-data/ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (storeTemplate !== undefined) {
                localVarQueryParameter['store-template'] = storeTemplate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new Rating Specification
         * @summary Post cwmsData ratings spec
         * @param {RatingSpec} ratingSpec 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataRatingsSpec: async (ratingSpec: RatingSpec, failIfExists?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingSpec' is not null or undefined
            assertParamExists('postCwmsDataRatingsSpec', 'ratingSpec', ratingSpec)
            const localVarPath = `/cwms-data/ratings/spec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (failIfExists !== undefined) {
                localVarQueryParameter['fail-if-exists'] = failIfExists;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ratingSpec, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new Rating Template
         * @summary Post cwmsData ratings template
         * @param {RatingTemplate} ratingTemplate 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataRatingsTemplate: async (ratingTemplate: RatingTemplate, failIfExists?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingTemplate' is not null or undefined
            assertParamExists('postCwmsDataRatingsTemplate', 'ratingTemplate', ratingTemplate)
            const localVarPath = `/cwms-data/ratings/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (failIfExists !== undefined) {
                localVarQueryParameter['fail-if-exists'] = failIfExists;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/xml;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ratingTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingsApi - functional programming interface
 * @export
 */
export const RatingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RatingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes requested rating specification
         * @summary Delete cwmsData ratings spec with ratingId
         * @param {string} ratingId The rating-spec-id of the ratings data to be deleted.
         * @param {string} office Specifies the owning office of the ratings to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataRatingsSpecWithRatingId(ratingId: string, office: string, method: DeleteMethod, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataRatingsSpecWithRatingId(ratingId, office, method, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.deleteCwmsDataRatingsSpecWithRatingId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deletes requested rating specification
         * @summary Delete cwmsData ratings template with templateId
         * @param {string} templateId The rating-template-id of the ratings data to be deleted.
         * @param {string} office Specifies the owning office of the ratings to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataRatingsTemplateWithTemplateId(templateId: string, office: string, method: DeleteMethod, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataRatingsTemplateWithTemplateId(templateId, office, method, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.deleteCwmsDataRatingsTemplateWithTemplateId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Delete cwmsData ratings with ratingId
         * @param {string} ratingId The rating-id of the effective dates to be deleted. 
         * @param {string} office Specifies the office of the ratings to be deleted.
         * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataRatingsWithRatingId(ratingId: string, office: string, begin: string, end: string, timezone?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataRatingsWithRatingId(ratingId, office, begin, end, timezone, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.deleteCwmsDataRatingsWithRatingId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData ratings
         * @param {string} [name] Specifies the name(s) of the rating whose data is to be included in the response. A case insensitive comparison is used to match names.
         * @param {string} [office] Specifies the owning office of the Rating(s) whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:  1. EN.   Specifies English unit system.  Rating values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Rating values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation Ratings. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [at] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.    json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataRatings(name?: string, office?: string, unit?: string, datum?: string, at?: string, end?: string, timezone?: string, format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataRatings(name, office, unit, datum, at, end, timezone, format, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.getCwmsDataRatings']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData ratings metadata
         * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [ratingIdMask] RegExp that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
         * @param {string} [start] Specifies the start of the time window of the effective dates to be included. If this field is not specified no start time will be used.
         * @param {string} [end] Specifies the end of the time window for effective dates to be included. If this field is not specified no end time will be used.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataRatingsMetadata(office?: string, ratingIdMask?: string, start?: string, end?: string, timezone?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingMetadataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataRatingsMetadata(office, ratingIdMask, start, end, timezone, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.getCwmsDataRatingsMetadata']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData ratings spec
         * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [ratingIdMask] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt;  that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataRatingsSpec(office?: string, ratingIdMask?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingSpecs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataRatingsSpec(office, ratingIdMask, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.getCwmsDataRatingsSpec']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData ratings spec with ratingId
         * @param {string} ratingId Specifies the rating-id of the Rating Spec to be included in the response
         * @param {string} office Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataRatingsSpecWithRatingId(ratingId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingSpec>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataRatingsSpecWithRatingId(ratingId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.getCwmsDataRatingsSpecWithRatingId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData ratings template
         * @param {string} [office] Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [templateIdMask] RegExp that specifies the rating template IDs to be included in the response. If this field is not specified, all rating templates shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataRatingsTemplate(office?: string, templateIdMask?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingTemplates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataRatingsTemplate(office, templateIdMask, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.getCwmsDataRatingsTemplate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData ratings template with templateId
         * @param {string} templateId Specifies the template whose data is to be included in the response
         * @param {string} office Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataRatingsTemplateWithTemplateId(templateId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RatingTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataRatingsTemplateWithTemplateId(templateId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.getCwmsDataRatingsTemplateWithTemplateId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS Rating Data
         * @summary Get cwmsData ratings with ratingId
         * @param {string} ratingId The rating-id of the effective dates to be retrieve. 
         * @param {string} office Specifies the owning office of the ratingset to be included in the response.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified no start time will be used.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified no end time will be used.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {DatabaseLoadMethod} [method] Specifies the retrieval method used.  If no method is provided EAGER will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataRatingsWithRatingId(ratingId: string, office: string, begin?: string, end?: string, timezone?: string, method?: DatabaseLoadMethod, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataRatingsWithRatingId(ratingId, office, begin, end, timezone, method, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.getCwmsDataRatingsWithRatingId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a RatingSet
         * @summary Patch cwmsData ratings with ratingId
         * @param {string} ratingId 
         * @param {object} body 
         * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataRatingsWithRatingId(ratingId: string, body: object, storeTemplate?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataRatingsWithRatingId(ratingId, body, storeTemplate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.patchCwmsDataRatingsWithRatingId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new RatingSet
         * @summary Post cwmsData ratings
         * @param {object} body 
         * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataRatings(body: object, storeTemplate?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataRatings(body, storeTemplate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.postCwmsDataRatings']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new Rating Specification
         * @summary Post cwmsData ratings spec
         * @param {RatingSpec} ratingSpec 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataRatingsSpec(ratingSpec: RatingSpec, failIfExists?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataRatingsSpec(ratingSpec, failIfExists, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.postCwmsDataRatingsSpec']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new Rating Template
         * @summary Post cwmsData ratings template
         * @param {RatingTemplate} ratingTemplate 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataRatingsTemplate(ratingTemplate: RatingTemplate, failIfExists?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataRatingsTemplate(ratingTemplate, failIfExists, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RatingsApi.postCwmsDataRatingsTemplate']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RatingsApi - factory interface
 * @export
 */
export const RatingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RatingsApiFp(configuration)
    return {
        /**
         * Deletes requested rating specification
         * @summary Delete cwmsData ratings spec with ratingId
         * @param {string} ratingId The rating-spec-id of the ratings data to be deleted.
         * @param {string} office Specifies the owning office of the ratings to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataRatingsSpecWithRatingId(ratingId: string, office: string, method: DeleteMethod, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataRatingsSpecWithRatingId(ratingId, office, method, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes requested rating specification
         * @summary Delete cwmsData ratings template with templateId
         * @param {string} templateId The rating-template-id of the ratings data to be deleted.
         * @param {string} office Specifies the owning office of the ratings to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataRatingsTemplateWithTemplateId(templateId: string, office: string, method: DeleteMethod, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataRatingsTemplateWithTemplateId(templateId, office, method, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete cwmsData ratings with ratingId
         * @param {string} ratingId The rating-id of the effective dates to be deleted. 
         * @param {string} office Specifies the office of the ratings to be deleted.
         * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataRatingsWithRatingId(ratingId: string, office: string, begin: string, end: string, timezone?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataRatingsWithRatingId(ratingId, office, begin, end, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData ratings
         * @param {string} [name] Specifies the name(s) of the rating whose data is to be included in the response. A case insensitive comparison is used to match names.
         * @param {string} [office] Specifies the owning office of the Rating(s) whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:  1. EN.   Specifies English unit system.  Rating values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Rating values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation Ratings. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [at] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.    json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatings(name?: string, office?: string, unit?: string, datum?: string, at?: string, end?: string, timezone?: string, format?: string, options?: any): AxiosPromise<object> {
            return localVarFp.getCwmsDataRatings(name, office, unit, datum, at, end, timezone, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData ratings metadata
         * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [ratingIdMask] RegExp that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
         * @param {string} [start] Specifies the start of the time window of the effective dates to be included. If this field is not specified no start time will be used.
         * @param {string} [end] Specifies the end of the time window for effective dates to be included. If this field is not specified no end time will be used.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsMetadata(office?: string, ratingIdMask?: string, start?: string, end?: string, timezone?: string, page?: string, pageSize?: number, options?: any): AxiosPromise<RatingMetadataList> {
            return localVarFp.getCwmsDataRatingsMetadata(office, ratingIdMask, start, end, timezone, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData ratings spec
         * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [ratingIdMask] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt;  that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsSpec(office?: string, ratingIdMask?: string, page?: string, pageSize?: number, options?: any): AxiosPromise<RatingSpecs> {
            return localVarFp.getCwmsDataRatingsSpec(office, ratingIdMask, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData ratings spec with ratingId
         * @param {string} ratingId Specifies the rating-id of the Rating Spec to be included in the response
         * @param {string} office Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsSpecWithRatingId(ratingId: string, office: string, options?: any): AxiosPromise<RatingSpec> {
            return localVarFp.getCwmsDataRatingsSpecWithRatingId(ratingId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData ratings template
         * @param {string} [office] Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {string} [templateIdMask] RegExp that specifies the rating template IDs to be included in the response. If this field is not specified, all rating templates shall be returned.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 100.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsTemplate(office?: string, templateIdMask?: string, page?: string, pageSize?: number, options?: any): AxiosPromise<RatingTemplates> {
            return localVarFp.getCwmsDataRatingsTemplate(office, templateIdMask, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData ratings template with templateId
         * @param {string} templateId Specifies the template whose data is to be included in the response
         * @param {string} office Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsTemplateWithTemplateId(templateId: string, office: string, options?: any): AxiosPromise<Array<RatingTemplate>> {
            return localVarFp.getCwmsDataRatingsTemplateWithTemplateId(templateId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS Rating Data
         * @summary Get cwmsData ratings with ratingId
         * @param {string} ratingId The rating-id of the effective dates to be retrieve. 
         * @param {string} office Specifies the owning office of the ratingset to be included in the response.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified no start time will be used.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified no end time will be used.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
         * @param {DatabaseLoadMethod} [method] Specifies the retrieval method used.  If no method is provided EAGER will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataRatingsWithRatingId(ratingId: string, office: string, begin?: string, end?: string, timezone?: string, method?: DatabaseLoadMethod, options?: any): AxiosPromise<object> {
            return localVarFp.getCwmsDataRatingsWithRatingId(ratingId, office, begin, end, timezone, method, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a RatingSet
         * @summary Patch cwmsData ratings with ratingId
         * @param {string} ratingId 
         * @param {object} body 
         * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataRatingsWithRatingId(ratingId: string, body: object, storeTemplate?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataRatingsWithRatingId(ratingId, body, storeTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new RatingSet
         * @summary Post cwmsData ratings
         * @param {object} body 
         * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataRatings(body: object, storeTemplate?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataRatings(body, storeTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new Rating Specification
         * @summary Post cwmsData ratings spec
         * @param {RatingSpec} ratingSpec 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataRatingsSpec(ratingSpec: RatingSpec, failIfExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataRatingsSpec(ratingSpec, failIfExists, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new Rating Template
         * @summary Post cwmsData ratings template
         * @param {RatingTemplate} ratingTemplate 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataRatingsTemplate(ratingTemplate: RatingTemplate, failIfExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataRatingsTemplate(ratingTemplate, failIfExists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RatingsApi - object-oriented interface
 * @export
 * @class RatingsApi
 * @extends {BaseAPI}
 */
export class RatingsApi extends BaseAPI {
    /**
     * Deletes requested rating specification
     * @summary Delete cwmsData ratings spec with ratingId
     * @param {string} ratingId The rating-spec-id of the ratings data to be deleted.
     * @param {string} office Specifies the owning office of the ratings to be deleted.
     * @param {DeleteMethod} method Specifies the delete method used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public deleteCwmsDataRatingsSpecWithRatingId(ratingId: string, office: string, method: DeleteMethod, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).deleteCwmsDataRatingsSpecWithRatingId(ratingId, office, method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes requested rating specification
     * @summary Delete cwmsData ratings template with templateId
     * @param {string} templateId The rating-template-id of the ratings data to be deleted.
     * @param {string} office Specifies the owning office of the ratings to be deleted.
     * @param {DeleteMethod} method Specifies the delete method used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public deleteCwmsDataRatingsTemplateWithTemplateId(templateId: string, office: string, method: DeleteMethod, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).deleteCwmsDataRatingsTemplateWithTemplateId(templateId, office, method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete cwmsData ratings with ratingId
     * @param {string} ratingId The rating-id of the effective dates to be deleted. 
     * @param {string} office Specifies the office of the ratings to be deleted.
     * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public deleteCwmsDataRatingsWithRatingId(ratingId: string, office: string, begin: string, end: string, timezone?: string, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).deleteCwmsDataRatingsWithRatingId(ratingId, office, begin, end, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData ratings
     * @param {string} [name] Specifies the name(s) of the rating whose data is to be included in the response. A case insensitive comparison is used to match names.
     * @param {string} [office] Specifies the owning office of the Rating(s) whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
     * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:  1. EN.   Specifies English unit system.  Rating values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Rating values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
     * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation Ratings. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
     * @param {string} [at] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time.
     * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time
     * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
     * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.    json (default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public getCwmsDataRatings(name?: string, office?: string, unit?: string, datum?: string, at?: string, end?: string, timezone?: string, format?: string, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).getCwmsDataRatings(name, office, unit, datum, at, end, timezone, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData ratings metadata
     * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
     * @param {string} [ratingIdMask] RegExp that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
     * @param {string} [start] Specifies the start of the time window of the effective dates to be included. If this field is not specified no start time will be used.
     * @param {string} [end] Specifies the end of the time window for effective dates to be included. If this field is not specified no end time will be used.
     * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public getCwmsDataRatingsMetadata(office?: string, ratingIdMask?: string, start?: string, end?: string, timezone?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).getCwmsDataRatingsMetadata(office, ratingIdMask, start, end, timezone, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData ratings spec
     * @param {string} [office] Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
     * @param {string} [ratingIdMask] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt;  that specifies the rating IDs to be included in the response. If this field is not specified, all Rating Specs shall be returned.
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public getCwmsDataRatingsSpec(office?: string, ratingIdMask?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).getCwmsDataRatingsSpec(office, ratingIdMask, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData ratings spec with ratingId
     * @param {string} ratingId Specifies the rating-id of the Rating Spec to be included in the response
     * @param {string} office Specifies the owning office of the Rating Specs whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public getCwmsDataRatingsSpecWithRatingId(ratingId: string, office: string, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).getCwmsDataRatingsSpecWithRatingId(ratingId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData ratings template
     * @param {string} [office] Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
     * @param {string} [templateIdMask] RegExp that specifies the rating template IDs to be included in the response. If this field is not specified, all rating templates shall be returned.
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public getCwmsDataRatingsTemplate(office?: string, templateIdMask?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).getCwmsDataRatingsTemplate(office, templateIdMask, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData ratings template with templateId
     * @param {string} templateId Specifies the template whose data is to be included in the response
     * @param {string} office Specifies the owning office of the Rating Templates whose data is to be included in the response. If this field is not specified, matching rating information from all offices shall be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public getCwmsDataRatingsTemplateWithTemplateId(templateId: string, office: string, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).getCwmsDataRatingsTemplateWithTemplateId(templateId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS Rating Data
     * @summary Get cwmsData ratings with ratingId
     * @param {string} ratingId The rating-id of the effective dates to be retrieve. 
     * @param {string} office Specifies the owning office of the ratingset to be included in the response.
     * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified no start time will be used.
     * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified no end time will be used.
     * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.
     * @param {DatabaseLoadMethod} [method] Specifies the retrieval method used.  If no method is provided EAGER will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public getCwmsDataRatingsWithRatingId(ratingId: string, office: string, begin?: string, end?: string, timezone?: string, method?: DatabaseLoadMethod, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).getCwmsDataRatingsWithRatingId(ratingId, office, begin, end, timezone, method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a RatingSet
     * @summary Patch cwmsData ratings with ratingId
     * @param {string} ratingId 
     * @param {object} body 
     * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public patchCwmsDataRatingsWithRatingId(ratingId: string, body: object, storeTemplate?: boolean, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).patchCwmsDataRatingsWithRatingId(ratingId, body, storeTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new RatingSet
     * @summary Post cwmsData ratings
     * @param {object} body 
     * @param {boolean} [storeTemplate] Also store updates to the rating template. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public postCwmsDataRatings(body: object, storeTemplate?: boolean, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).postCwmsDataRatings(body, storeTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new Rating Specification
     * @summary Post cwmsData ratings spec
     * @param {RatingSpec} ratingSpec 
     * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public postCwmsDataRatingsSpec(ratingSpec: RatingSpec, failIfExists?: boolean, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).postCwmsDataRatingsSpec(ratingSpec, failIfExists, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new Rating Template
     * @summary Post cwmsData ratings template
     * @param {RatingTemplate} ratingTemplate 
     * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingsApi
     */
    public postCwmsDataRatingsTemplate(ratingTemplate: RatingTemplate, failIfExists?: boolean, options?: RawAxiosRequestConfig) {
        return RatingsApiFp(this.configuration).postCwmsDataRatingsTemplate(ratingTemplate, failIfExists, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatesApi - axios parameter creator
 * @export
 */
export const StatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataStates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/states`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatesApi - functional programming interface
 * @export
 */
export const StatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataStates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<State>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataStates(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['StatesApi.getCwmsDataStates']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * StatesApi - factory interface
 * @export
 */
export const StatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataStates(options?: any): AxiosPromise<Array<State>> {
            return localVarFp.getCwmsDataStates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatesApi - object-oriented interface
 * @export
 * @class StatesApi
 * @extends {BaseAPI}
 */
export class StatesApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData states
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatesApi
     */
    public getCwmsDataStates(options?: RawAxiosRequestConfig) {
        return StatesApiFp(this.configuration).getCwmsDataStates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeSeriesApi - axios parameter creator
 * @export
 */
export const TimeSeriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete cwmsData timeseries with timeseries
         * @param {string} timeseries The timeseries-id of the timeseries values to be deleted. 
         * @param {string} office Specifies the office of the timeseries to be deleted.
         * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
         * @param {string} [versionDate] The version date/time of the time series in the specified or default time zone. If NULL, the earliest or latest version date will be used depending on p_max_version.
         * @param {boolean} [startTimeInclusive] A flag specifying whether any data at the start time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;after&lt;/em&gt;&lt;/b&gt; the start time (\&#39;False\&#39;).  Default value is True
         * @param {boolean} [endTimeInclusive] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether any data at the end time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;before&lt;/em&gt;&lt;/b&gt; the end time (\&#39;False\&#39;). Default value is False
         * @param {boolean} [maxVersion] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to use the earliest (\&#39;False\&#39;) or latest (\&#39;True\&#39;) version date for each time if p_version_date is NULL.  Default is \&#39;True\&#39;
         * @param {boolean} [overrideProtection] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to delete protected data. Default is False
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesWithTimeseries: async (timeseries: string, office: string, begin: string, end: string, timezone?: string, versionDate?: string, startTimeInclusive?: boolean, endTimeInclusive?: boolean, maxVersion?: boolean, overrideProtection?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeseries' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesWithTimeseries', 'timeseries', timeseries)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesWithTimeseries', 'office', office)
            // verify required parameter 'begin' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesWithTimeseries', 'begin', begin)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesWithTimeseries', 'end', end)
            const localVarPath = `/cwms-data/timeseries/{timeseries}`
                .replace(`{${"timeseries"}}`, encodeURIComponent(String(timeseries)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (versionDate !== undefined) {
                localVarQueryParameter['version-date'] = versionDate;
            }

            if (startTimeInclusive !== undefined) {
                localVarQueryParameter['start-time-inclusive'] = startTimeInclusive;
            }

            if (endTimeInclusive !== undefined) {
                localVarQueryParameter['end-time-inclusive'] = endTimeInclusive;
            }

            if (maxVersion !== undefined) {
                localVarQueryParameter['max-version'] = maxVersion;
            }

            if (overrideProtection !== undefined) {
                localVarQueryParameter['override-protection'] = overrideProtection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cwmsData timeseries
         * @param {string} name Specifies the name(s) of the time series whose data is to be included in the response. A case insensitive comparison is used to match names.
         * @param {string} [office] Specifies the owning office of the time series(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   (default) Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time. The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.  Ignored if begin was specified with offset and timezone.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default)
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseries: async (name: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCwmsDataTimeseries', 'name', name)
            const localVarPath = `/cwms-data/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (datum !== undefined) {
                localVarQueryParameter['datum'] = datum;
            }

            if (begin !== undefined) {
                localVarQueryParameter['begin'] = begin;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a TimeSeries with provided values
         * @summary Patch cwmsData timeseries with timeseries
         * @param {string} timeseries Full CWMS Timeseries name
         * @param {TimeSeries} timeSeries 
         * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
         * @param {boolean} [createAsLrts] 
         * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
         * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data.  \&quot;\&#39;true\&#39; or \&#39;false\&#39;\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataTimeseriesWithTimeseries: async (timeseries: string, timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeseries' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesWithTimeseries', 'timeseries', timeseries)
            // verify required parameter 'timeSeries' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesWithTimeseries', 'timeSeries', timeSeries)
            const localVarPath = `/cwms-data/timeseries/{timeseries}`
                .replace(`{${"timeseries"}}`, encodeURIComponent(String(timeseries)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (versionDate !== undefined) {
                localVarQueryParameter['version-date'] = versionDate;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (createAsLrts !== undefined) {
                localVarQueryParameter['create-as-lrts'] = createAsLrts;
            }

            if (storeRule !== undefined) {
                localVarQueryParameter['store-rule'] = storeRule;
            }

            if (overrideProtection !== undefined) {
                localVarQueryParameter['override-protection'] = overrideProtection;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSeries, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new TimeSeries, will store any data provided
         * @summary Post cwmsData timeseries
         * @param {TimeSeries} timeSeries 
         * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
         * @param {boolean} [createAsLrts] Flag indicating if timeseries should be created as Local Regular Time Series. \&#39;True\&#39; or \&#39;False\&#39;, default is \&#39;False\&#39;
         * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
         * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data. \&#39;True\&#39; or \&#39;False\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseries: async (timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSeries' is not null or undefined
            assertParamExists('postCwmsDataTimeseries', 'timeSeries', timeSeries)
            const localVarPath = `/cwms-data/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (versionDate !== undefined) {
                localVarQueryParameter['version-date'] = versionDate;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (createAsLrts !== undefined) {
                localVarQueryParameter['create-as-lrts'] = createAsLrts;
            }

            if (storeRule !== undefined) {
                localVarQueryParameter['store-rule'] = storeRule;
            }

            if (overrideProtection !== undefined) {
                localVarQueryParameter['override-protection'] = overrideProtection;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSeries, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeSeriesApi - functional programming interface
 * @export
 */
export const TimeSeriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeSeriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete cwmsData timeseries with timeseries
         * @param {string} timeseries The timeseries-id of the timeseries values to be deleted. 
         * @param {string} office Specifies the office of the timeseries to be deleted.
         * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
         * @param {string} [versionDate] The version date/time of the time series in the specified or default time zone. If NULL, the earliest or latest version date will be used depending on p_max_version.
         * @param {boolean} [startTimeInclusive] A flag specifying whether any data at the start time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;after&lt;/em&gt;&lt;/b&gt; the start time (\&#39;False\&#39;).  Default value is True
         * @param {boolean} [endTimeInclusive] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether any data at the end time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;before&lt;/em&gt;&lt;/b&gt; the end time (\&#39;False\&#39;). Default value is False
         * @param {boolean} [maxVersion] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to use the earliest (\&#39;False\&#39;) or latest (\&#39;True\&#39;) version date for each time if p_version_date is NULL.  Default is \&#39;True\&#39;
         * @param {boolean} [overrideProtection] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to delete protected data. Default is False
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataTimeseriesWithTimeseries(timeseries: string, office: string, begin: string, end: string, timezone?: string, versionDate?: string, startTimeInclusive?: boolean, endTimeInclusive?: boolean, maxVersion?: boolean, overrideProtection?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataTimeseriesWithTimeseries(timeseries, office, begin, end, timezone, versionDate, startTimeInclusive, endTimeInclusive, maxVersion, overrideProtection, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesApi.deleteCwmsDataTimeseriesWithTimeseries']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get cwmsData timeseries
         * @param {string} name Specifies the name(s) of the time series whose data is to be included in the response. A case insensitive comparison is used to match names.
         * @param {string} [office] Specifies the owning office of the time series(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   (default) Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time. The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.  Ignored if begin was specified with offset and timezone.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default)
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseries(name: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSeries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseries(name, office, unit, datum, begin, end, timezone, format, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesApi.getCwmsDataTimeseries']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a TimeSeries with provided values
         * @summary Patch cwmsData timeseries with timeseries
         * @param {string} timeseries Full CWMS Timeseries name
         * @param {TimeSeries} timeSeries 
         * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
         * @param {boolean} [createAsLrts] 
         * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
         * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data.  \&quot;\&#39;true\&#39; or \&#39;false\&#39;\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataTimeseriesWithTimeseries(timeseries: string, timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataTimeseriesWithTimeseries(timeseries, timeSeries, versionDate, timezone, createAsLrts, storeRule, overrideProtection, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesApi.patchCwmsDataTimeseriesWithTimeseries']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new TimeSeries, will store any data provided
         * @summary Post cwmsData timeseries
         * @param {TimeSeries} timeSeries 
         * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
         * @param {boolean} [createAsLrts] Flag indicating if timeseries should be created as Local Regular Time Series. \&#39;True\&#39; or \&#39;False\&#39;, default is \&#39;False\&#39;
         * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
         * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data. \&#39;True\&#39; or \&#39;False\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataTimeseries(timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataTimeseries(timeSeries, versionDate, timezone, createAsLrts, storeRule, overrideProtection, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesApi.postCwmsDataTimeseries']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TimeSeriesApi - factory interface
 * @export
 */
export const TimeSeriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeSeriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete cwmsData timeseries with timeseries
         * @param {string} timeseries The timeseries-id of the timeseries values to be deleted. 
         * @param {string} office Specifies the office of the timeseries to be deleted.
         * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
         * @param {string} [versionDate] The version date/time of the time series in the specified or default time zone. If NULL, the earliest or latest version date will be used depending on p_max_version.
         * @param {boolean} [startTimeInclusive] A flag specifying whether any data at the start time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;after&lt;/em&gt;&lt;/b&gt; the start time (\&#39;False\&#39;).  Default value is True
         * @param {boolean} [endTimeInclusive] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether any data at the end time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;before&lt;/em&gt;&lt;/b&gt; the end time (\&#39;False\&#39;). Default value is False
         * @param {boolean} [maxVersion] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to use the earliest (\&#39;False\&#39;) or latest (\&#39;True\&#39;) version date for each time if p_version_date is NULL.  Default is \&#39;True\&#39;
         * @param {boolean} [overrideProtection] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to delete protected data. Default is False
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesWithTimeseries(timeseries: string, office: string, begin: string, end: string, timezone?: string, versionDate?: string, startTimeInclusive?: boolean, endTimeInclusive?: boolean, maxVersion?: boolean, overrideProtection?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataTimeseriesWithTimeseries(timeseries, office, begin, end, timezone, versionDate, startTimeInclusive, endTimeInclusive, maxVersion, overrideProtection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cwmsData timeseries
         * @param {string} name Specifies the name(s) of the time series whose data is to be included in the response. A case insensitive comparison is used to match names.
         * @param {string} [office] Specifies the owning office of the time series(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
         * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   (default) Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
         * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
         * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time. The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.  Ignored if begin was specified with offset and timezone.
         * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default)
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseries(name: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options?: any): AxiosPromise<TimeSeries> {
            return localVarFp.getCwmsDataTimeseries(name, office, unit, datum, begin, end, timezone, format, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a TimeSeries with provided values
         * @summary Patch cwmsData timeseries with timeseries
         * @param {string} timeseries Full CWMS Timeseries name
         * @param {TimeSeries} timeSeries 
         * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
         * @param {boolean} [createAsLrts] 
         * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
         * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data.  \&quot;\&#39;true\&#39; or \&#39;false\&#39;\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataTimeseriesWithTimeseries(timeseries: string, timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataTimeseriesWithTimeseries(timeseries, timeSeries, versionDate, timezone, createAsLrts, storeRule, overrideProtection, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new TimeSeries, will store any data provided
         * @summary Post cwmsData timeseries
         * @param {TimeSeries} timeSeries 
         * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
         * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
         * @param {boolean} [createAsLrts] Flag indicating if timeseries should be created as Local Regular Time Series. \&#39;True\&#39; or \&#39;False\&#39;, default is \&#39;False\&#39;
         * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
         * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data. \&#39;True\&#39; or \&#39;False\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseries(timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataTimeseries(timeSeries, versionDate, timezone, createAsLrts, storeRule, overrideProtection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeSeriesApi - object-oriented interface
 * @export
 * @class TimeSeriesApi
 * @extends {BaseAPI}
 */
export class TimeSeriesApi extends BaseAPI {
    /**
     * 
     * @summary Delete cwmsData timeseries with timeseries
     * @param {string} timeseries The timeseries-id of the timeseries values to be deleted. 
     * @param {string} office Specifies the office of the timeseries to be deleted.
     * @param {string} begin The start of the time window to delete. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} end The end of the time window to delete.The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} [timezone] This field specifies a default timezone to be used if the format of the begin, end, or version-date parameters do not include offset or time zone information. Defaults to UTC.
     * @param {string} [versionDate] The version date/time of the time series in the specified or default time zone. If NULL, the earliest or latest version date will be used depending on p_max_version.
     * @param {boolean} [startTimeInclusive] A flag specifying whether any data at the start time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;after&lt;/em&gt;&lt;/b&gt; the start time (\&#39;False\&#39;).  Default value is True
     * @param {boolean} [endTimeInclusive] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether any data at the end time should be deleted (\&#39;True\&#39;) or only data &lt;b&gt;&lt;em&gt;before&lt;/em&gt;&lt;/b&gt; the end time (\&#39;False\&#39;). Default value is False
     * @param {boolean} [maxVersion] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to use the earliest (\&#39;False\&#39;) or latest (\&#39;True\&#39;) version date for each time if p_version_date is NULL.  Default is \&#39;True\&#39;
     * @param {boolean} [overrideProtection] A flag (\&#39;True\&#39;/\&#39;False\&#39;) specifying whether to delete protected data. Default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesApi
     */
    public deleteCwmsDataTimeseriesWithTimeseries(timeseries: string, office: string, begin: string, end: string, timezone?: string, versionDate?: string, startTimeInclusive?: boolean, endTimeInclusive?: boolean, maxVersion?: boolean, overrideProtection?: boolean, options?: RawAxiosRequestConfig) {
        return TimeSeriesApiFp(this.configuration).deleteCwmsDataTimeseriesWithTimeseries(timeseries, office, begin, end, timezone, versionDate, startTimeInclusive, endTimeInclusive, maxVersion, overrideProtection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cwmsData timeseries
     * @param {string} name Specifies the name(s) of the time series whose data is to be included in the response. A case insensitive comparison is used to match names.
     * @param {string} [office] Specifies the owning office of the time series(s) whose data is to be included in the response. If this field is not specified, matching location level information from all offices shall be returned.
     * @param {string} [unit] Specifies the unit or unit system of the response. Valid values for the unit field are:   1. EN.   (default) Specifies English unit system.  Location level values will be in the default English units for their parameters.  2. SI.   Specifies the SI unit system.  Location level values will be in the default SI units for their parameters.  3. Other. Any unit returned in the response to the units URI request that is appropriate for the requested parameters.
     * @param {string} [datum] Specifies the elevation datum of the response. This field affects only elevation location levels. Valid values for this field are:  1. NAVD88.  The elevation values will in the specified or default units above the NAVD-88 datum.  2. NGVD29.  The elevation values will be in the specified or default units above the NGVD-29 datum.
     * @param {string} [begin] Specifies the start of the time window for data to be included in the response. If this field is not specified, any required time window begins 24 hours prior to the specified or default end time. The format for this field is ISO 8601 extended, with optional offset and timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} [end] Specifies the end of the time window for data to be included in the response. If this field is not specified, any required time window ends at the current time. The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;YYYY-MM-dd\&#39;T\&#39;hh:mm:ss[Z\&#39;[\&#39;VV\&#39;]\&#39;]\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} [timezone] Specifies the time zone of the values of the begin and end fields (unless otherwise specified), as well as the time zone of any times in the response. If this field is not specified, the default time zone of UTC shall be used.  Ignored if begin was specified with offset and timezone.
     * @param {string} [format] Specifies the encoding format of the response. Valid values for the format field for this URI are:  1.    tab  2.    csv  3.    xml  4.  wml2 (only if name field is specified)  5.    json (default)
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 500.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesApi
     */
    public getCwmsDataTimeseries(name: string, office?: string, unit?: string, datum?: string, begin?: string, end?: string, timezone?: string, format?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return TimeSeriesApiFp(this.configuration).getCwmsDataTimeseries(name, office, unit, datum, begin, end, timezone, format, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a TimeSeries with provided values
     * @summary Patch cwmsData timeseries with timeseries
     * @param {string} timeseries Full CWMS Timeseries name
     * @param {TimeSeries} timeSeries 
     * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
     * @param {boolean} [createAsLrts] 
     * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
     * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data.  \&quot;\&#39;true\&#39; or \&#39;false\&#39;\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesApi
     */
    public patchCwmsDataTimeseriesWithTimeseries(timeseries: string, timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options?: RawAxiosRequestConfig) {
        return TimeSeriesApiFp(this.configuration).patchCwmsDataTimeseriesWithTimeseries(timeseries, timeSeries, versionDate, timezone, createAsLrts, storeRule, overrideProtection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new TimeSeries, will store any data provided
     * @summary Post cwmsData timeseries
     * @param {TimeSeries} timeSeries 
     * @param {string} [versionDate] Specifies the version date for the timeseries to create. If this field is not specified, a null version date will be used.  The format for this field is ISO 8601 extended, with optional timezone, i.e., \&#39;format\&#39;, e.g., \&#39;2021-06-10T13:00:00-0700[PST8PDT]\&#39;.
     * @param {string} [timezone] Specifies the time zone of the version-date field (unless otherwise specified). If this field is not specified, the default time zone of UTC shall be used.  Ignored if version-date was specified with offset and timezone.
     * @param {boolean} [createAsLrts] Flag indicating if timeseries should be created as Local Regular Time Series. \&#39;True\&#39; or \&#39;False\&#39;, default is \&#39;False\&#39;
     * @param {StoreRule} [storeRule] The business rule to use when merging the incoming with existing data
     * @param {boolean} [overrideProtection] A flag to ignore the protected data quality when storing data. \&#39;True\&#39; or \&#39;False\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesApi
     */
    public postCwmsDataTimeseries(timeSeries: TimeSeries, versionDate?: string, timezone?: string, createAsLrts?: boolean, storeRule?: StoreRule, overrideProtection?: boolean, options?: RawAxiosRequestConfig) {
        return TimeSeriesApiFp(this.configuration).postCwmsDataTimeseries(timeSeries, versionDate, timezone, createAsLrts, storeRule, overrideProtection, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeSeriesCategoriesApi - axios parameter creator
 * @export
 */
export const TimeSeriesCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes requested time series category
         * @summary Delete cwmsData timeseries category with categoryId
         * @param {string} categoryId The time series category to be deleted
         * @param {string} office Specifies the owning office of the time series category to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to delete any time series groups in this time series category. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesCategoryWithCategoryId: async (categoryId: string, office: string, cascadeDelete?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesCategoryWithCategoryId', 'categoryId', categoryId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesCategoryWithCategoryId', 'office', office)
            const localVarPath = `/cwms-data/timeseries/category/{category-id}`
                .replace(`{${"category-id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (cascadeDelete !== undefined) {
                localVarQueryParameter['cascade-delete'] = cascadeDelete;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS timeseries category Data
         * @summary Get cwmsData timeseries category
         * @param {string} [office] Specifies the owning office of the timeseries category(ies) whose data is to be included in the response. If this field is not specified, matching timeseries category information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesCategory: async (office?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/timeseries/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves requested timeseries category
         * @summary Get cwmsData timeseries category with categoryId
         * @param {string} categoryId Specifies the Category whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the timeseries category whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesCategoryWithCategoryId: async (categoryId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesCategoryWithCategoryId', 'categoryId', categoryId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesCategoryWithCategoryId', 'office', office)
            const localVarPath = `/cwms-data/timeseries/category/{category-id}`
                .replace(`{${"category-id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new TimeSeriesCategory
         * @summary Post cwmsData timeseries category
         * @param {TimeSeriesCategory} timeSeriesCategory 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseriesCategory: async (timeSeriesCategory: TimeSeriesCategory, failIfExists?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSeriesCategory' is not null or undefined
            assertParamExists('postCwmsDataTimeseriesCategory', 'timeSeriesCategory', timeSeriesCategory)
            const localVarPath = `/cwms-data/timeseries/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (failIfExists !== undefined) {
                localVarQueryParameter['fail-if-exists'] = failIfExists;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSeriesCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeSeriesCategoriesApi - functional programming interface
 * @export
 */
export const TimeSeriesCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeSeriesCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes requested time series category
         * @summary Delete cwmsData timeseries category with categoryId
         * @param {string} categoryId The time series category to be deleted
         * @param {string} office Specifies the owning office of the time series category to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to delete any time series groups in this time series category. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataTimeseriesCategoryWithCategoryId(categoryId: string, office: string, cascadeDelete?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataTimeseriesCategoryWithCategoryId(categoryId, office, cascadeDelete, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesCategoriesApi.deleteCwmsDataTimeseriesCategoryWithCategoryId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS timeseries category Data
         * @summary Get cwmsData timeseries category
         * @param {string} [office] Specifies the owning office of the timeseries category(ies) whose data is to be included in the response. If this field is not specified, matching timeseries category information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseriesCategory(office?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeSeriesCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseriesCategory(office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesCategoriesApi.getCwmsDataTimeseriesCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves requested timeseries category
         * @summary Get cwmsData timeseries category with categoryId
         * @param {string} categoryId Specifies the Category whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the timeseries category whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseriesCategoryWithCategoryId(categoryId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSeriesCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseriesCategoryWithCategoryId(categoryId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesCategoriesApi.getCwmsDataTimeseriesCategoryWithCategoryId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new TimeSeriesCategory
         * @summary Post cwmsData timeseries category
         * @param {TimeSeriesCategory} timeSeriesCategory 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataTimeseriesCategory(timeSeriesCategory: TimeSeriesCategory, failIfExists?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataTimeseriesCategory(timeSeriesCategory, failIfExists, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesCategoriesApi.postCwmsDataTimeseriesCategory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TimeSeriesCategoriesApi - factory interface
 * @export
 */
export const TimeSeriesCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeSeriesCategoriesApiFp(configuration)
    return {
        /**
         * Deletes requested time series category
         * @summary Delete cwmsData timeseries category with categoryId
         * @param {string} categoryId The time series category to be deleted
         * @param {string} office Specifies the owning office of the time series category to be deleted
         * @param {boolean} [cascadeDelete] Specifies whether to delete any time series groups in this time series category. Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesCategoryWithCategoryId(categoryId: string, office: string, cascadeDelete?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataTimeseriesCategoryWithCategoryId(categoryId, office, cascadeDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS timeseries category Data
         * @summary Get cwmsData timeseries category
         * @param {string} [office] Specifies the owning office of the timeseries category(ies) whose data is to be included in the response. If this field is not specified, matching timeseries category information from all offices shall be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesCategory(office?: string, options?: any): AxiosPromise<Array<TimeSeriesCategory>> {
            return localVarFp.getCwmsDataTimeseriesCategory(office, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves requested timeseries category
         * @summary Get cwmsData timeseries category with categoryId
         * @param {string} categoryId Specifies the Category whose data is to be included in the response.
         * @param {string} office Specifies the owning office of the timeseries category whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesCategoryWithCategoryId(categoryId: string, office: string, options?: any): AxiosPromise<TimeSeriesCategory> {
            return localVarFp.getCwmsDataTimeseriesCategoryWithCategoryId(categoryId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new TimeSeriesCategory
         * @summary Post cwmsData timeseries category
         * @param {TimeSeriesCategory} timeSeriesCategory 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseriesCategory(timeSeriesCategory: TimeSeriesCategory, failIfExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataTimeseriesCategory(timeSeriesCategory, failIfExists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeSeriesCategoriesApi - object-oriented interface
 * @export
 * @class TimeSeriesCategoriesApi
 * @extends {BaseAPI}
 */
export class TimeSeriesCategoriesApi extends BaseAPI {
    /**
     * Deletes requested time series category
     * @summary Delete cwmsData timeseries category with categoryId
     * @param {string} categoryId The time series category to be deleted
     * @param {string} office Specifies the owning office of the time series category to be deleted
     * @param {boolean} [cascadeDelete] Specifies whether to delete any time series groups in this time series category. Default: false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesCategoriesApi
     */
    public deleteCwmsDataTimeseriesCategoryWithCategoryId(categoryId: string, office: string, cascadeDelete?: boolean, options?: RawAxiosRequestConfig) {
        return TimeSeriesCategoriesApiFp(this.configuration).deleteCwmsDataTimeseriesCategoryWithCategoryId(categoryId, office, cascadeDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS timeseries category Data
     * @summary Get cwmsData timeseries category
     * @param {string} [office] Specifies the owning office of the timeseries category(ies) whose data is to be included in the response. If this field is not specified, matching timeseries category information from all offices shall be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesCategoriesApi
     */
    public getCwmsDataTimeseriesCategory(office?: string, options?: RawAxiosRequestConfig) {
        return TimeSeriesCategoriesApiFp(this.configuration).getCwmsDataTimeseriesCategory(office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves requested timeseries category
     * @summary Get cwmsData timeseries category with categoryId
     * @param {string} categoryId Specifies the Category whose data is to be included in the response.
     * @param {string} office Specifies the owning office of the timeseries category whose data is to be included in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesCategoriesApi
     */
    public getCwmsDataTimeseriesCategoryWithCategoryId(categoryId: string, office: string, options?: RawAxiosRequestConfig) {
        return TimeSeriesCategoriesApiFp(this.configuration).getCwmsDataTimeseriesCategoryWithCategoryId(categoryId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new TimeSeriesCategory
     * @summary Post cwmsData timeseries category
     * @param {TimeSeriesCategory} timeSeriesCategory 
     * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesCategoriesApi
     */
    public postCwmsDataTimeseriesCategory(timeSeriesCategory: TimeSeriesCategory, failIfExists?: boolean, options?: RawAxiosRequestConfig) {
        return TimeSeriesCategoriesApiFp(this.configuration).postCwmsDataTimeseriesCategory(timeSeriesCategory, failIfExists, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeSeriesIdentifierApi - axios parameter creator
 * @export
 */
export const TimeSeriesIdentifierApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes requested timeseries identifier
         * @summary Delete cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId The timeseries-id of the timeseries to be deleted. 
         * @param {string} office Specifies the owning office of the timeseries to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId: async (timeseriesId: string, office: string, method: DeleteMethod, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeseriesId' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'timeseriesId', timeseriesId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'office', office)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'method', method)
            const localVarPath = `/cwms-data/timeseries/identifier-descriptor/{timeseries-id}`
                .replace(`{${"timeseries-id"}}`, encodeURIComponent(String(timeseriesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS timeseries identifier descriptorData
         * @summary Get cwmsData timeseries identifierDescriptor
         * @param {string} [office] Specifies the owning office of the timeseries identifier(s) whose data is to be included in the response. If this field is not specified, matching timeseries identifier information from all offices shall be returned.
         * @param {string} [timeseriesIdRegex] A case insensitive RegExp that will be applied to the timeseries-id field. If this field is not specified the results will not be constrained by timeseries-id.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesIdentifierDescriptor: async (office?: string, timeseriesIdRegex?: string, page?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/timeseries/identifier-descriptor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (timeseriesIdRegex !== undefined) {
                localVarQueryParameter['timeseries-id-regex'] = timeseriesIdRegex;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves requested timeseries identifier descriptor
         * @summary Get cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId Specifies the identifier of the timeseries to be included in the response.
         * @param {string} office Specifies the owning office of the timeseries identifier to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId: async (timeseriesId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeseriesId' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'timeseriesId', timeseriesId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'office', office)
            const localVarPath = `/cwms-data/timeseries/identifier-descriptor/{timeseries-id}`
                .replace(`{${"timeseries-id"}}`, encodeURIComponent(String(timeseriesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId 
         * @param {string} timeseriesId2 A new timeseries-id.  If specified a rename operation will be performed and snap-forward, snap-backward, and active must not be provided
         * @param {string} office Specifies the owning office of the timeseries identifier to be updated
         * @param {number} [intervalOffset] The offset into the data interval in minutes.  If specified and a new timeseries-id is also specified both will be passed to a rename operation.  May also be passed to update operation.
         * @param {number} [snapForward] The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
         * @param {number} [snapBackward] The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
         * @param {boolean} [active] \&#39;True\&#39; or \&#39;true\&#39; if the time series is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId: async (timeseriesId: string, timeseriesId2: string, office: string, intervalOffset?: number, snapForward?: number, snapBackward?: number, active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeseriesId' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'timeseriesId', timeseriesId)
            // verify required parameter 'timeseriesId2' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'timeseriesId2', timeseriesId2)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId', 'office', office)
            const localVarPath = `/cwms-data/timeseries/identifier-descriptor/{timeseries-id}`
                .replace(`{${"timeseries-id"}}`, encodeURIComponent(String(timeseriesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (timeseriesId2 !== undefined) {
                localVarQueryParameter['timeseries-id'] = timeseriesId2;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (intervalOffset !== undefined) {
                localVarQueryParameter['interval-offset'] = intervalOffset;
            }

            if (snapForward !== undefined) {
                localVarQueryParameter['snap-forward'] = snapForward;
            }

            if (snapBackward !== undefined) {
                localVarQueryParameter['snap-backward'] = snapBackward;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new TimeSeriesIdentifierDescriptor
         * @summary Post cwmsData timeseries identifierDescriptor
         * @param {TimeSeriesIdentifierDescriptor} timeSeriesIdentifierDescriptor 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseriesIdentifierDescriptor: async (timeSeriesIdentifierDescriptor: TimeSeriesIdentifierDescriptor, failIfExists?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSeriesIdentifierDescriptor' is not null or undefined
            assertParamExists('postCwmsDataTimeseriesIdentifierDescriptor', 'timeSeriesIdentifierDescriptor', timeSeriesIdentifierDescriptor)
            const localVarPath = `/cwms-data/timeseries/identifier-descriptor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (failIfExists !== undefined) {
                localVarQueryParameter['fail-if-exists'] = failIfExists;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;version=2';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSeriesIdentifierDescriptor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeSeriesIdentifierApi - functional programming interface
 * @export
 */
export const TimeSeriesIdentifierApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeSeriesIdentifierApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes requested timeseries identifier
         * @summary Delete cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId The timeseries-id of the timeseries to be deleted. 
         * @param {string} office Specifies the owning office of the timeseries to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, office: string, method: DeleteMethod, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, office, method, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesIdentifierApi.deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS timeseries identifier descriptorData
         * @summary Get cwmsData timeseries identifierDescriptor
         * @param {string} [office] Specifies the owning office of the timeseries identifier(s) whose data is to be included in the response. If this field is not specified, matching timeseries identifier information from all offices shall be returned.
         * @param {string} [timeseriesIdRegex] A case insensitive RegExp that will be applied to the timeseries-id field. If this field is not specified the results will not be constrained by timeseries-id.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseriesIdentifierDescriptor(office?: string, timeseriesIdRegex?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSeriesIdentifierDescriptors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseriesIdentifierDescriptor(office, timeseriesIdRegex, page, pageSize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesIdentifierApi.getCwmsDataTimeseriesIdentifierDescriptor']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves requested timeseries identifier descriptor
         * @summary Get cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId Specifies the identifier of the timeseries to be included in the response.
         * @param {string} office Specifies the owning office of the timeseries identifier to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSeriesIdentifierDescriptor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesIdentifierApi.getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Patch cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId 
         * @param {string} timeseriesId2 A new timeseries-id.  If specified a rename operation will be performed and snap-forward, snap-backward, and active must not be provided
         * @param {string} office Specifies the owning office of the timeseries identifier to be updated
         * @param {number} [intervalOffset] The offset into the data interval in minutes.  If specified and a new timeseries-id is also specified both will be passed to a rename operation.  May also be passed to update operation.
         * @param {number} [snapForward] The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
         * @param {number} [snapBackward] The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
         * @param {boolean} [active] \&#39;True\&#39; or \&#39;true\&#39; if the time series is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, timeseriesId2: string, office: string, intervalOffset?: number, snapForward?: number, snapBackward?: number, active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, timeseriesId2, office, intervalOffset, snapForward, snapBackward, active, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesIdentifierApi.patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new TimeSeriesIdentifierDescriptor
         * @summary Post cwmsData timeseries identifierDescriptor
         * @param {TimeSeriesIdentifierDescriptor} timeSeriesIdentifierDescriptor 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataTimeseriesIdentifierDescriptor(timeSeriesIdentifierDescriptor: TimeSeriesIdentifierDescriptor, failIfExists?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataTimeseriesIdentifierDescriptor(timeSeriesIdentifierDescriptor, failIfExists, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeSeriesIdentifierApi.postCwmsDataTimeseriesIdentifierDescriptor']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TimeSeriesIdentifierApi - factory interface
 * @export
 */
export const TimeSeriesIdentifierApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeSeriesIdentifierApiFp(configuration)
    return {
        /**
         * Deletes requested timeseries identifier
         * @summary Delete cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId The timeseries-id of the timeseries to be deleted. 
         * @param {string} office Specifies the owning office of the timeseries to be deleted.
         * @param {DeleteMethod} method Specifies the delete method used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, office: string, method: DeleteMethod, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, office, method, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS timeseries identifier descriptorData
         * @summary Get cwmsData timeseries identifierDescriptor
         * @param {string} [office] Specifies the owning office of the timeseries identifier(s) whose data is to be included in the response. If this field is not specified, matching timeseries identifier information from all offices shall be returned.
         * @param {string} [timeseriesIdRegex] A case insensitive RegExp that will be applied to the timeseries-id field. If this field is not specified the results will not be constrained by timeseries-id.
         * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
         * @param {number} [pageSize] How many entries per page returned. Default 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesIdentifierDescriptor(office?: string, timeseriesIdRegex?: string, page?: string, pageSize?: number, options?: any): AxiosPromise<TimeSeriesIdentifierDescriptors> {
            return localVarFp.getCwmsDataTimeseriesIdentifierDescriptor(office, timeseriesIdRegex, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves requested timeseries identifier descriptor
         * @summary Get cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId Specifies the identifier of the timeseries to be included in the response.
         * @param {string} office Specifies the owning office of the timeseries identifier to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, office: string, options?: any): AxiosPromise<TimeSeriesIdentifierDescriptor> {
            return localVarFp.getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch cwmsData timeseries identifierDescriptor with timeseriesId
         * @param {string} timeseriesId 
         * @param {string} timeseriesId2 A new timeseries-id.  If specified a rename operation will be performed and snap-forward, snap-backward, and active must not be provided
         * @param {string} office Specifies the owning office of the timeseries identifier to be updated
         * @param {number} [intervalOffset] The offset into the data interval in minutes.  If specified and a new timeseries-id is also specified both will be passed to a rename operation.  May also be passed to update operation.
         * @param {number} [snapForward] The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
         * @param {number} [snapBackward] The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
         * @param {boolean} [active] \&#39;True\&#39; or \&#39;true\&#39; if the time series is active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, timeseriesId2: string, office: string, intervalOffset?: number, snapForward?: number, snapBackward?: number, active?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, timeseriesId2, office, intervalOffset, snapForward, snapBackward, active, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new TimeSeriesIdentifierDescriptor
         * @summary Post cwmsData timeseries identifierDescriptor
         * @param {TimeSeriesIdentifierDescriptor} timeSeriesIdentifierDescriptor 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseriesIdentifierDescriptor(timeSeriesIdentifierDescriptor: TimeSeriesIdentifierDescriptor, failIfExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataTimeseriesIdentifierDescriptor(timeSeriesIdentifierDescriptor, failIfExists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeSeriesIdentifierApi - object-oriented interface
 * @export
 * @class TimeSeriesIdentifierApi
 * @extends {BaseAPI}
 */
export class TimeSeriesIdentifierApi extends BaseAPI {
    /**
     * Deletes requested timeseries identifier
     * @summary Delete cwmsData timeseries identifierDescriptor with timeseriesId
     * @param {string} timeseriesId The timeseries-id of the timeseries to be deleted. 
     * @param {string} office Specifies the owning office of the timeseries to be deleted.
     * @param {DeleteMethod} method Specifies the delete method used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesIdentifierApi
     */
    public deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, office: string, method: DeleteMethod, options?: RawAxiosRequestConfig) {
        return TimeSeriesIdentifierApiFp(this.configuration).deleteCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, office, method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS timeseries identifier descriptorData
     * @summary Get cwmsData timeseries identifierDescriptor
     * @param {string} [office] Specifies the owning office of the timeseries identifier(s) whose data is to be included in the response. If this field is not specified, matching timeseries identifier information from all offices shall be returned.
     * @param {string} [timeseriesIdRegex] A case insensitive RegExp that will be applied to the timeseries-id field. If this field is not specified the results will not be constrained by timeseries-id.
     * @param {string} [page] This end point can return a lot of data, this identifies where in the request you are. This is an opaque value, and can be obtained from the \&#39;next-page\&#39; value in the response.
     * @param {number} [pageSize] How many entries per page returned. Default 500.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesIdentifierApi
     */
    public getCwmsDataTimeseriesIdentifierDescriptor(office?: string, timeseriesIdRegex?: string, page?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return TimeSeriesIdentifierApiFp(this.configuration).getCwmsDataTimeseriesIdentifierDescriptor(office, timeseriesIdRegex, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves requested timeseries identifier descriptor
     * @summary Get cwmsData timeseries identifierDescriptor with timeseriesId
     * @param {string} timeseriesId Specifies the identifier of the timeseries to be included in the response.
     * @param {string} office Specifies the owning office of the timeseries identifier to be included in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesIdentifierApi
     */
    public getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, office: string, options?: RawAxiosRequestConfig) {
        return TimeSeriesIdentifierApiFp(this.configuration).getCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch cwmsData timeseries identifierDescriptor with timeseriesId
     * @param {string} timeseriesId 
     * @param {string} timeseriesId2 A new timeseries-id.  If specified a rename operation will be performed and snap-forward, snap-backward, and active must not be provided
     * @param {string} office Specifies the owning office of the timeseries identifier to be updated
     * @param {number} [intervalOffset] The offset into the data interval in minutes.  If specified and a new timeseries-id is also specified both will be passed to a rename operation.  May also be passed to update operation.
     * @param {number} [snapForward] The new snap forward tolerance in minutes. This specifies how many minutes before the expected data time that data will be considered to be on time.
     * @param {number} [snapBackward] The new snap backward tolerance in minutes. This specifies how many minutes after the expected data time that data will be considered to be on time.
     * @param {boolean} [active] \&#39;True\&#39; or \&#39;true\&#39; if the time series is active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesIdentifierApi
     */
    public patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId: string, timeseriesId2: string, office: string, intervalOffset?: number, snapForward?: number, snapBackward?: number, active?: boolean, options?: RawAxiosRequestConfig) {
        return TimeSeriesIdentifierApiFp(this.configuration).patchCwmsDataTimeseriesIdentifierDescriptorWithTimeseriesId(timeseriesId, timeseriesId2, office, intervalOffset, snapForward, snapBackward, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new TimeSeriesIdentifierDescriptor
     * @summary Post cwmsData timeseries identifierDescriptor
     * @param {TimeSeriesIdentifierDescriptor} timeSeriesIdentifierDescriptor 
     * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSeriesIdentifierApi
     */
    public postCwmsDataTimeseriesIdentifierDescriptor(timeSeriesIdentifierDescriptor: TimeSeriesIdentifierDescriptor, failIfExists?: boolean, options?: RawAxiosRequestConfig) {
        return TimeSeriesIdentifierApiFp(this.configuration).postCwmsDataTimeseriesIdentifierDescriptor(timeSeriesIdentifierDescriptor, failIfExists, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeZonesApi - axios parameter creator
 * @export
 */
export const TimeZonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData timezones
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimezones: async (format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/timezones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeZonesApi - functional programming interface
 * @export
 */
export const TimeZonesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeZonesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData timezones
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimezones(format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimezones(format, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeZonesApi.getCwmsDataTimezones']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TimeZonesApi - factory interface
 * @export
 */
export const TimeZonesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeZonesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData timezones
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimezones(format?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCwmsDataTimezones(format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeZonesApi - object-oriented interface
 * @export
 * @class TimeZonesApi
 * @extends {BaseAPI}
 */
export class TimeZonesApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData timezones
     * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeZonesApi
     */
    public getCwmsDataTimezones(format?: string, options?: RawAxiosRequestConfig) {
        return TimeZonesApiFp(this.configuration).getCwmsDataTimezones(format, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeseriesGroupsApi - axios parameter creator
 * @export
 */
export const TimeseriesGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes requested time series group
         * @summary Delete cwmsData timeseries group with groupId
         * @param {string} groupId The time series group to be deleted
         * @param {string} categoryId Specifies the time series category of the time series group to be deleted
         * @param {string} office Specifies the owning office of the time series group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesGroupWithGroupId: async (groupId: string, categoryId: string, office: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesGroupWithGroupId', 'groupId', groupId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesGroupWithGroupId', 'categoryId', categoryId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('deleteCwmsDataTimeseriesGroupWithGroupId', 'office', office)
            const localVarPath = `/cwms-data/timeseries/group/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (categoryId !== undefined) {
                localVarQueryParameter['category-id'] = categoryId;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns CWMS Timeseries Groups Data
         * @summary Get cwmsData timeseries group
         * @param {string} [office] Specifies the owning office of the timeseries group(s) whose data is to be included in the response. If this field is not specified, matching timeseries groups information from all offices shall be returned.
         * @param {boolean} [includeAssigned] Include the assigned timeseries in the returned timeseries groups. (default: true)
         * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
         * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesGroup: async (office?: string, includeAssigned?: boolean, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/timeseries/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (includeAssigned !== undefined) {
                localVarQueryParameter['include-assigned'] = includeAssigned;
            }

            if (timeseriesCategoryLike !== undefined) {
                localVarQueryParameter['timeseries-category-like'] = timeseriesCategoryLike;
            }

            if (timeseriesGroupLike !== undefined) {
                localVarQueryParameter['timeseries-group-like'] = timeseriesGroupLike;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves requested timeseries group
         * @summary Get cwmsData timeseries group with groupId
         * @param {string} groupId Specifies the timeseries group whose data is to be included in the response
         * @param {string} office Specifies the owning office of the timeseries group whose data is to be included in the response.
         * @param {string} categoryId Specifies the category containing the timeseries group whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesGroupWithGroupId: async (groupId: string, office: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesGroupWithGroupId', 'groupId', groupId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesGroupWithGroupId', 'office', office)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCwmsDataTimeseriesGroupWithGroupId', 'categoryId', categoryId)
            const localVarPath = `/cwms-data/timeseries/group/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category-id'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing TimeSeriesGroup
         * @summary Patch cwmsData timeseries group with groupId
         * @param {string} groupId 
         * @param {string} office Specifies the owning office of the time series group to be updated
         * @param {TimeSeriesGroup} timeSeriesGroup 
         * @param {boolean} [replaceAssignedTs] Specifies whether to unassign all existing time series before assigning new time series specified in the content body Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataTimeseriesGroupWithGroupId: async (groupId: string, office: string, timeSeriesGroup: TimeSeriesGroup, replaceAssignedTs?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesGroupWithGroupId', 'groupId', groupId)
            // verify required parameter 'office' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesGroupWithGroupId', 'office', office)
            // verify required parameter 'timeSeriesGroup' is not null or undefined
            assertParamExists('patchCwmsDataTimeseriesGroupWithGroupId', 'timeSeriesGroup', timeSeriesGroup)
            const localVarPath = `/cwms-data/timeseries/group/{group-id}`
                .replace(`{${"group-id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (replaceAssignedTs !== undefined) {
                localVarQueryParameter['replace-assigned-ts'] = replaceAssignedTs;
            }

            if (office !== undefined) {
                localVarQueryParameter['office'] = office;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSeriesGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new TimeSeriesGroup
         * @summary Post cwmsData timeseries group
         * @param {TimeSeriesGroup} timeSeriesGroup 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseriesGroup: async (timeSeriesGroup: TimeSeriesGroup, failIfExists?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSeriesGroup' is not null or undefined
            assertParamExists('postCwmsDataTimeseriesGroup', 'timeSeriesGroup', timeSeriesGroup)
            const localVarPath = `/cwms-data/timeseries/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication CwmsAAACacAuth required

            if (failIfExists !== undefined) {
                localVarQueryParameter['fail-if-exists'] = failIfExists;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSeriesGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeseriesGroupsApi - functional programming interface
 * @export
 */
export const TimeseriesGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeseriesGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes requested time series group
         * @summary Delete cwmsData timeseries group with groupId
         * @param {string} groupId The time series group to be deleted
         * @param {string} categoryId Specifies the time series category of the time series group to be deleted
         * @param {string} office Specifies the owning office of the time series group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCwmsDataTimeseriesGroupWithGroupId(groupId: string, categoryId: string, office: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCwmsDataTimeseriesGroupWithGroupId(groupId, categoryId, office, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeseriesGroupsApi.deleteCwmsDataTimeseriesGroupWithGroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Returns CWMS Timeseries Groups Data
         * @summary Get cwmsData timeseries group
         * @param {string} [office] Specifies the owning office of the timeseries group(s) whose data is to be included in the response. If this field is not specified, matching timeseries groups information from all offices shall be returned.
         * @param {boolean} [includeAssigned] Include the assigned timeseries in the returned timeseries groups. (default: true)
         * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
         * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseriesGroup(office?: string, includeAssigned?: boolean, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeSeriesGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseriesGroup(office, includeAssigned, timeseriesCategoryLike, timeseriesGroupLike, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeseriesGroupsApi.getCwmsDataTimeseriesGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Retrieves requested timeseries group
         * @summary Get cwmsData timeseries group with groupId
         * @param {string} groupId Specifies the timeseries group whose data is to be included in the response
         * @param {string} office Specifies the owning office of the timeseries group whose data is to be included in the response.
         * @param {string} categoryId Specifies the category containing the timeseries group whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataTimeseriesGroupWithGroupId(groupId: string, office: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSeriesGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataTimeseriesGroupWithGroupId(groupId, office, categoryId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeseriesGroupsApi.getCwmsDataTimeseriesGroupWithGroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update existing TimeSeriesGroup
         * @summary Patch cwmsData timeseries group with groupId
         * @param {string} groupId 
         * @param {string} office Specifies the owning office of the time series group to be updated
         * @param {TimeSeriesGroup} timeSeriesGroup 
         * @param {boolean} [replaceAssignedTs] Specifies whether to unassign all existing time series before assigning new time series specified in the content body Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCwmsDataTimeseriesGroupWithGroupId(groupId: string, office: string, timeSeriesGroup: TimeSeriesGroup, replaceAssignedTs?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCwmsDataTimeseriesGroupWithGroupId(groupId, office, timeSeriesGroup, replaceAssignedTs, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeseriesGroupsApi.patchCwmsDataTimeseriesGroupWithGroupId']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create new TimeSeriesGroup
         * @summary Post cwmsData timeseries group
         * @param {TimeSeriesGroup} timeSeriesGroup 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCwmsDataTimeseriesGroup(timeSeriesGroup: TimeSeriesGroup, failIfExists?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCwmsDataTimeseriesGroup(timeSeriesGroup, failIfExists, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TimeseriesGroupsApi.postCwmsDataTimeseriesGroup']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TimeseriesGroupsApi - factory interface
 * @export
 */
export const TimeseriesGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeseriesGroupsApiFp(configuration)
    return {
        /**
         * Deletes requested time series group
         * @summary Delete cwmsData timeseries group with groupId
         * @param {string} groupId The time series group to be deleted
         * @param {string} categoryId Specifies the time series category of the time series group to be deleted
         * @param {string} office Specifies the owning office of the time series group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCwmsDataTimeseriesGroupWithGroupId(groupId: string, categoryId: string, office: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCwmsDataTimeseriesGroupWithGroupId(groupId, categoryId, office, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns CWMS Timeseries Groups Data
         * @summary Get cwmsData timeseries group
         * @param {string} [office] Specifies the owning office of the timeseries group(s) whose data is to be included in the response. If this field is not specified, matching timeseries groups information from all offices shall be returned.
         * @param {boolean} [includeAssigned] Include the assigned timeseries in the returned timeseries groups. (default: true)
         * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
         * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesGroup(office?: string, includeAssigned?: boolean, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, options?: any): AxiosPromise<Array<TimeSeriesGroup>> {
            return localVarFp.getCwmsDataTimeseriesGroup(office, includeAssigned, timeseriesCategoryLike, timeseriesGroupLike, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves requested timeseries group
         * @summary Get cwmsData timeseries group with groupId
         * @param {string} groupId Specifies the timeseries group whose data is to be included in the response
         * @param {string} office Specifies the owning office of the timeseries group whose data is to be included in the response.
         * @param {string} categoryId Specifies the category containing the timeseries group whose data is to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataTimeseriesGroupWithGroupId(groupId: string, office: string, categoryId: string, options?: any): AxiosPromise<TimeSeriesGroup> {
            return localVarFp.getCwmsDataTimeseriesGroupWithGroupId(groupId, office, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing TimeSeriesGroup
         * @summary Patch cwmsData timeseries group with groupId
         * @param {string} groupId 
         * @param {string} office Specifies the owning office of the time series group to be updated
         * @param {TimeSeriesGroup} timeSeriesGroup 
         * @param {boolean} [replaceAssignedTs] Specifies whether to unassign all existing time series before assigning new time series specified in the content body Default: false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCwmsDataTimeseriesGroupWithGroupId(groupId: string, office: string, timeSeriesGroup: TimeSeriesGroup, replaceAssignedTs?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.patchCwmsDataTimeseriesGroupWithGroupId(groupId, office, timeSeriesGroup, replaceAssignedTs, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new TimeSeriesGroup
         * @summary Post cwmsData timeseries group
         * @param {TimeSeriesGroup} timeSeriesGroup 
         * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCwmsDataTimeseriesGroup(timeSeriesGroup: TimeSeriesGroup, failIfExists?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postCwmsDataTimeseriesGroup(timeSeriesGroup, failIfExists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeseriesGroupsApi - object-oriented interface
 * @export
 * @class TimeseriesGroupsApi
 * @extends {BaseAPI}
 */
export class TimeseriesGroupsApi extends BaseAPI {
    /**
     * Deletes requested time series group
     * @summary Delete cwmsData timeseries group with groupId
     * @param {string} groupId The time series group to be deleted
     * @param {string} categoryId Specifies the time series category of the time series group to be deleted
     * @param {string} office Specifies the owning office of the time series group to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeseriesGroupsApi
     */
    public deleteCwmsDataTimeseriesGroupWithGroupId(groupId: string, categoryId: string, office: string, options?: RawAxiosRequestConfig) {
        return TimeseriesGroupsApiFp(this.configuration).deleteCwmsDataTimeseriesGroupWithGroupId(groupId, categoryId, office, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns CWMS Timeseries Groups Data
     * @summary Get cwmsData timeseries group
     * @param {string} [office] Specifies the owning office of the timeseries group(s) whose data is to be included in the response. If this field is not specified, matching timeseries groups information from all offices shall be returned.
     * @param {boolean} [includeAssigned] Include the assigned timeseries in the returned timeseries groups. (default: true)
     * @param {string} [timeseriesCategoryLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries category id
     * @param {string} [timeseriesGroupLike] Posix &lt;a href&#x3D;\&quot;regexp.html\&quot;&gt;regular expression&lt;/a&gt; matching against the timeseries group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeseriesGroupsApi
     */
    public getCwmsDataTimeseriesGroup(office?: string, includeAssigned?: boolean, timeseriesCategoryLike?: string, timeseriesGroupLike?: string, options?: RawAxiosRequestConfig) {
        return TimeseriesGroupsApiFp(this.configuration).getCwmsDataTimeseriesGroup(office, includeAssigned, timeseriesCategoryLike, timeseriesGroupLike, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves requested timeseries group
     * @summary Get cwmsData timeseries group with groupId
     * @param {string} groupId Specifies the timeseries group whose data is to be included in the response
     * @param {string} office Specifies the owning office of the timeseries group whose data is to be included in the response.
     * @param {string} categoryId Specifies the category containing the timeseries group whose data is to be included in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeseriesGroupsApi
     */
    public getCwmsDataTimeseriesGroupWithGroupId(groupId: string, office: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return TimeseriesGroupsApiFp(this.configuration).getCwmsDataTimeseriesGroupWithGroupId(groupId, office, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing TimeSeriesGroup
     * @summary Patch cwmsData timeseries group with groupId
     * @param {string} groupId 
     * @param {string} office Specifies the owning office of the time series group to be updated
     * @param {TimeSeriesGroup} timeSeriesGroup 
     * @param {boolean} [replaceAssignedTs] Specifies whether to unassign all existing time series before assigning new time series specified in the content body Default: false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeseriesGroupsApi
     */
    public patchCwmsDataTimeseriesGroupWithGroupId(groupId: string, office: string, timeSeriesGroup: TimeSeriesGroup, replaceAssignedTs?: boolean, options?: RawAxiosRequestConfig) {
        return TimeseriesGroupsApiFp(this.configuration).patchCwmsDataTimeseriesGroupWithGroupId(groupId, office, timeSeriesGroup, replaceAssignedTs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new TimeSeriesGroup
     * @summary Post cwmsData timeseries group
     * @param {TimeSeriesGroup} timeSeriesGroup 
     * @param {boolean} [failIfExists] Create will fail if provided ID already exists. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeseriesGroupsApi
     */
    public postCwmsDataTimeseriesGroup(timeSeriesGroup: TimeSeriesGroup, failIfExists?: boolean, options?: RawAxiosRequestConfig) {
        return TimeseriesGroupsApiFp(this.configuration).postCwmsDataTimeseriesGroup(timeSeriesGroup, failIfExists, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UnitsApi - axios parameter creator
 * @export
 */
export const UnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get cwmsData units
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataUnits: async (format?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cwms-data/units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnitsApi - functional programming interface
 * @export
 */
export const UnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData units
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCwmsDataUnits(format?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCwmsDataUnits(format, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UnitsApi.getCwmsDataUnits']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UnitsApi - factory interface
 * @export
 */
export const UnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnitsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get cwmsData units
         * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCwmsDataUnits(format?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getCwmsDataUnits(format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnitsApi - object-oriented interface
 * @export
 * @class UnitsApi
 * @extends {BaseAPI}
 */
export class UnitsApi extends BaseAPI {
    /**
     * 
     * @summary Get cwmsData units
     * @param {string} [format] Specifies the encoding format of the response. Valid value for the format field for this URI are:  1. tab  2. csv   3. xml  4. json (default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public getCwmsDataUnits(format?: string, options?: RawAxiosRequestConfig) {
        return UnitsApiFp(this.configuration).getCwmsDataUnits(format, options).then((request) => request(this.axios, this.basePath));
    }
}



